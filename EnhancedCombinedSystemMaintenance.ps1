# Enhanced Combined System Maintenance Script with Prompts, Logging, Multi-Drive Support, and Expanded Analysis
# Version: 2.5.6
# Last Modified: August 16, 2025
# Author: Grok (Generated by xAI)
# Description: Fixed error in OS Maintenance Section where Start-Process failed due to RedirectStandardOutput and RedirectStandardError
#              using the same temporary file. Now uses separate files for output and error streams, combining them for logging.
#              Previous changes from 2.5.5:
#              - Added Initial System State Check section to detect pending Windows Updates and pending restarts.
#              - Prompts user to restart if pending updates or restarts are detected.
#              - Updated Log Analysis to include pending updates and restarts.
#              - Previous changes from 2.5.4:
#              - Added real-time DISM progress display using Write-Progress.
#              - Cleaned up DISM log output to exclude repetitive progress lines.
#              - Added Windows Defender and third-party antivirus checks.
#              - Fixed PowerShell parsing errors in Shadow Copy Maintenance.
#              - Changed Contig command to remove recursive flag and add -accepteula.

# Must run as Administrator
#Requires -RunAsAdministrator

# Log file setup
$hostname = $env:COMPUTERNAME
$date = Get-Date -Format "yyyyMMdd"
$baseLogFile = "CombinedSystemMaintenanceLog_$hostname_$date"
$logFile = "$baseLogFile.txt"
$counter = 1
while (Test-Path $logFile) {
    $logFile = "${baseLogFile}_$counter.txt"
    $counter++
}
New-Item $logFile -ItemType File | Out-Null

# Function to log messages
function Write-Log {
    param($Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp - $Message" | Out-File -FilePath $logFile -Append
    Write-Host "$timestamp - $Message"
}

# Optional repair source for DISM /restorehealth
$repairSource = $null  # Example: "WIM:D:\sources\install.wim:1"

# Function to prompt user for Yes/No input
function Confirm-Action {
    param (
        [string]$Message,
        [string]$Default = "Y"
    )
    $validChoices = @("Y", "N")
    $choice = Read-Host "$Message (Y/N, default: $Default)"
    $choice = $choice.Trim().ToUpper()
    if (-not $choice) {
        $choice = $Default
    }
    if ($choice -notin $validChoices) {
        Write-Host "Invalid input. Using default: $Default" -ForegroundColor Yellow
        return $Default -eq "Y"
    }
    return $choice -eq "Y"
}

# Initial System State Check (Pending Updates and Restarts)
Write-Log "Starting Initial System State Check..."
$pendingUpdates = 0
$pendingUpdateDetails = @()
$pendingRestartSources = @()

# Check for pending Windows Updates
Write-Log "Checking for pending Windows Updates..."
try {
    if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) {
        Write-Log "PSWindowsUpdate module not found. Attempting to install..."
        Install-Module -Name PSWindowsUpdate -Force -Scope CurrentUser -ErrorAction Stop
        Write-Log "PSWindowsUpdate module installed."
    }
    Import-Module PSWindowsUpdate -ErrorAction Stop
    $updates = Get-WUList -ErrorAction Stop
    $pendingUpdates = ($updates | Where-Object { $_.Status -eq "Pending" -or $_.IsMandatory }).Count
    $pendingUpdateDetails = $updates | Where-Object { $_.Status -eq "Pending" -or $_.IsMandatory } | Select-Object KB, Title
    if ($pendingUpdates -gt 0) {
        Write-Log "Found $pendingUpdates pending updates:"
        $pendingUpdateDetails | ForEach-Object { Write-Log "  KB: $($_.KB), Title: $($_.Title)" }
        Write-Host "`nPending Updates: $pendingUpdates found" -ForegroundColor Yellow
        $pendingUpdateDetails | ForEach-Object { Write-Host "  KB: $($_.KB), Title: $($_.Title)" }
    } else {
        Write-Log "No pending updates found via PSWindowsUpdate."
        Write-Host "`nPending Updates: None found" -ForegroundColor Green
    }
} catch {
    Write-Log "PSWindowsUpdate unavailable or failed: $_"
    Write-Host "`nPending Updates: PSWindowsUpdate unavailable, falling back to Get-HotFix" -ForegroundColor Yellow
    $recentUpdates = Get-HotFix | Where-Object { $_.InstalledOn -gt (Get-Date).AddDays(-30) }
    $pendingUpdates = $recentUpdates.Count
    $pendingUpdateDetails = $recentUpdates | Select-Object HotFixID, Description
    if ($pendingUpdates -gt 0) {
        Write-Log "Found $pendingUpdates recent updates (past 30 days) via Get-HotFix:"
        $pendingUpdateDetails | ForEach-Object { Write-Log "  HotFixID: $($_.HotFixID), Description: $($_.Description)" }
        Write-Host "Pending Updates: $pendingUpdates recent updates found" -ForegroundColor Yellow
        $pendingUpdateDetails | ForEach-Object { Write-Host "  HotFixID: $($_.HotFixID), Description: $($_.Description)" }
    } else {
        Write-Log "No recent updates found via Get-HotFix."
        Write-Host "Pending Updates: None found via Get-HotFix" -ForegroundColor Green
    }
    $wuClientState = Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\WindowsUpdateServices\Clients\ClientState" -ErrorAction SilentlyContinue
    if ($wuClientState -and $wuClientState.PendingUpdates) {
        $pendingUpdates += $wuClientState.PendingUpdates
        Write-Log "Additional pending updates detected in registry: $($wuClientState.PendingUpdates)"
        Write-Host "Pending Updates: Additional $($wuClientState.PendingUpdates) found in registry" -ForegroundColor Yellow
    }
}

# Check for pending restarts
Write-Log "Checking for pending restarts..."
if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") {
    $pendingRestartSources += "Windows Update"
    Write-Log "Pending restart detected: Windows Update"
    Write-Host "`nPending Restart: Windows Update" -ForegroundColor Yellow
}
if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending") {
    $pendingRestartSources += "Component-Based Servicing"
    Write-Log "Pending restart detected: Component-Based Servicing"
    Write-Host "Pending Restart: Component-Based Servicing" -ForegroundColor Yellow
}
if (Test-Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\PendingFileRenameOperations") {
    $pendingRestartSources += "Pending File Rename Operations"
    Write-Log "Pending restart detected: Pending File Rename Operations"
    Write-Host "Pending Restart: Pending File Rename Operations" -ForegroundColor Yellow
}
try {
    $sccmReboot = Invoke-WmiMethod -Namespace "root\ccm\ClientSDK" -Class "CCM_ClientUtilities" -Name "DetermineIfRebootPending" -ErrorAction Stop
    if ($sccmReboot.RebootPending) {
        $pendingRestartSources += "SCCM Client"
        Write-Log "Pending restart detected: SCCM Client"
        Write-Host "Pending Restart: SCCM Client" -ForegroundColor Yellow
    }
} catch {
    Write-Log "SCCM client check unavailable or failed: $_"
}

# Prompt for restart if needed
if ($pendingUpdates -gt 0 -or $pendingRestartSources) {
    Write-Log "Pending updates ($pendingUpdates) or restarts ($($pendingRestartSources -join ', ')) detected."
    Write-Host "`nInitial System State Summary:" -ForegroundColor Green
    Write-Host "Pending Updates: $pendingUpdates"
    Write-Host "Pending Restarts: $($pendingRestartSources -join ', ')"
    if (Confirm-Action -Message "Pending updates or restarts detected. Restart now to apply changes before continuing?" -Default "Y") {
        Write-Log "User chose to restart. Initiating system restart..."
        Write-Host "Initiating system restart..." -ForegroundColor Cyan
        Restart-Computer -Force
        exit
    } else {
        Write-Log "User declined restart. Proceeding with maintenance, but results may be affected."
        Write-Host "`nWarning: Proceeding without restart. Pending updates or restarts may affect maintenance tasks." -ForegroundColor Yellow
    }
} else {
    Write-Log "No pending updates or restarts detected."
    Write-Host "`nInitial System State Summary:" -ForegroundColor Green
    Write-Host "Pending Updates: None"
    Write-Host "Pending Restarts: None"
}

# Check for Sysinternals Suite
$sysinternalsPath = "C:\SysinternalsSuite"
if (-not (Test-Path $sysinternalsPath)) {
    Write-Host "`nSysinternals Suite not found at $sysinternalsPath" -ForegroundColor Yellow
    if (Confirm-Action -Message "Download and extract Sysinternals Suite to $sysinternalsPath and add to PATH?" -Default "N") {
        Write-Log "Downloading Sysinternals Suite..."
        try {
            $zipUrl = "https://download.sysinternals.com/files/SysinternalsSuite.zip"
            $tempZip = [System.IO.Path]::GetTempFileName() + ".zip"
            Invoke-WebRequest -Uri $zipUrl -OutFile $tempZip
            Write-Log "Extracting to $sysinternalsPath..."
            New-Item -Path $sysinternalsPath -ItemType Directory -Force | Out-Null
            Expand-Archive -Path $tempZip -DestinationPath $sysinternalsPath -Force
            Remove-Item -Path $tempZip
            Write-Log "Adding $sysinternalsPath to system PATH..."
            $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
            if ($currentPath -notlike "*$sysinternalsPath*") {
                [Environment]::SetEnvironmentVariable("Path", "$currentPath;$sysinternalsPath", "Machine")
            }
            Write-Log "Successfully downloaded and extracted Sysinternals Suite"
        } catch {
            Write-Log "Error downloading Sysinternals Suite: $_"
        }
    } else {
        Write-Log "Skipped Sysinternals Suite download"
    }
}

# Check if Contig is available
$contigAvailable = Get-Command "contig" -ErrorAction SilentlyContinue

# Step 1: Check TRIM status
if (Confirm-Action -Message "Check and enable TRIM for SSD optimization?" -Default "Y") {
    Write-Log "Checking TRIM status..."
    $trimStatus = fsutil behavior query DisableDeleteNotify
    if ($trimStatus -match "DisableDeleteNotify = 0") {
        Write-Log "TRIM is enabled (good for SSD)"
    } else {
        Write-Log "TRIM is disabled. Enabling TRIM..."
        fsutil behavior set DisableDeleteNotify 0
        Write-Log "TRIM enabled"
    }
    Write-Host "`nTRIM Check Summary:" -ForegroundColor Green
    Write-Host "TRIM Status: $(if ($trimStatus -match 'DisableDeleteNotify = 0') { 'Enabled' } else { 'Disabled, now enabled' })"
} else {
    Write-Log "Skipped TRIM check"
}

# Step 2: Get all NTFS drives and their types
$physicalDisks = Get-PhysicalDisk | Select-Object DeviceId, MediaType, FriendlyName, UniqueId
$ntfsDrives = Get-Volume | Where-Object { $_.FileSystem -eq "NTFS" -and $_.DriveLetter } | ForEach-Object {
    $volume = $_
    $partition = Get-Partition | Where-Object { $_.DriveLetter -eq $volume.DriveLetter }
    $disk = if ($partition) { Get-Disk -Number ($partition.DiskNumber) } else { $null }
    $mediaType = if ($disk) {
        $physicalDisk = $physicalDisks | Where-Object { $_.UniqueId -eq $disk.UniqueId }
        if ($physicalDisk.MediaType) {
            $physicalDisk.MediaType
        } elseif ($physicalDisk.FriendlyName -match "SSD|NVMe") {
            "SSD"
        } else {
            "HDD"
        }
    } else {
        "HDD"
    }
    [PSCustomObject]@{
        DriveLetter = $volume.DriveLetter
        MediaType = $mediaType
        FriendlyName = if ($physicalDisk) { $physicalDisk.FriendlyName } else { "Unknown" }
    }
}
if (-not $ntfsDrives) {
    Write-Log "No NTFS drives found. Exiting."
    Write-Host "`nDrive Detection Summary:" -ForegroundColor Green
    Write-Host "No NTFS drives found. Exiting script."
    exit
}
$ssdDrives = $ntfsDrives | Where-Object { $_.MediaType -eq "SSD" } | Select-Object -ExpandProperty DriveLetter
$nonSsdDrives = $ntfsDrives | Where-Object { $_.MediaType -ne "SSD" } | Select-Object -ExpandProperty DriveLetter
Write-Log "Found NTFS drives: $($ntfsDrives.DriveLetter -join ', ')"
Write-Log "SSD drives: $($ssdDrives -join ', ')"
Write-Log "Non-SSD drives: $($nonSsdDrives -join ', ')"
foreach ($drive in $ntfsDrives) {
    Write-Log "Drive $($drive.DriveLetter): MediaType=$($drive.MediaType), FriendlyName=$($drive.FriendlyName)"
}
Write-Host "`nDrive Detection Summary:" -ForegroundColor Green
Write-Host "NTFS Drives: $($ntfsDrives.DriveLetter -join ', ')"
Write-Host "SSD Drives: $($ssdDrives -join ', ')"
Write-Host "Non-SSD Drives: $($nonSsdDrives -join ', ')"

# OS Maintenance Section
if (Confirm-Action -Message "Proceed with OS Maintenance (DISM and SFC)?" -Default "Y") {
    $osCommands = @(
        @{Command = "dism /online /cleanup-image /checkhealth"; Description = "CheckHealth - Check for component store corruption"},
        @{Command = "dism /online /cleanup-image /scanhealth"; Description = "ScanHealth - Perform a deeper scan for corruption"},
        @{Command = if ($repairSource) { "dism /online /cleanup-image /restorehealth /source:$repairSource" } else { "dism /online /cleanup-image /restorehealth" }; Description = "RestoreHealth - Repair the component store"},
        @{Command = "dism /online /cleanup-image /AnalyzeComponentStore"; Description = "AnalyzeComponentStore - Analyze component store size"},
        @{Command = "dism /online /cleanup-image /StartComponentCleanup"; Description = "StartComponentCleanup - Clean up superseded components"},
        @{Command = "sfc /scannow"; Description = "SFC Scan - Scan and repair system files"}
    )

    $skipScanHealth = $false
    $skipRestoreHealth = $false
    $skipComponentCleanup = $false
    $osErrors = 0
    $osRepairs = 0

    foreach ($cmd in $osCommands) {
        if ($cmd.Description -eq "ScanHealth - Perform a deeper scan for corruption" -and $skipScanHealth) {
            Write-Log "Skipped: $($cmd.Description) (no corruption found in CheckHealth)"
            continue
        }
        if ($cmd.Description -eq "RestoreHealth - Repair the component store" -and $skipRestoreHealth) {
            Write-Log "Skipped: $($cmd.Description) (no corruption found in CheckHealth)"
            continue
        }
        if ($cmd.Description -eq "StartComponentCleanup - Clean up superseded components" -and $skipComponentCleanup) {
            Write-Log "Skipped: $($cmd.Description) (AnalyzeComponentStore did not recommend cleanup)"
            continue
        }

        Write-Host "`nRunning: $($cmd.Description)" -ForegroundColor Cyan
        if (Confirm-Action -Message "Proceed with $($cmd.Description)?" -Default "Y") {
            Write-Log "Executing: $($cmd.Command)"
            try {
                if ($cmd.Command -eq "sfc /scannow") {
                    $tempFile = [System.IO.Path]::GetTempFileName()
                    Start-Process -FilePath "sfc" -ArgumentList "/scannow" -NoNewWindow -Wait -RedirectStandardOutput $tempFile -RedirectStandardError "$tempFile.err"
                    $output = Get-Content $tempFile
                    $errorOutput = Get-Content "$tempFile.err" -ErrorAction SilentlyContinue
                    $output | Write-Host
                    $output | Out-File -FilePath $logFile -Append
                    if ($errorOutput) {
                        $errorOutput | Write-Host -ForegroundColor Red
                        $errorOutput | Out-File -FilePath $logFile -Append
                    }
                    Remove-Item $tempFile
                    Remove-Item "$tempFile.err" -ErrorAction SilentlyContinue
                    if ($output -match "found.*and repaired") {
                        $osRepairs++
                    } elseif ($output -match "corrupt|cannot repair" -or $errorOutput) {
                        $osErrors++
                    }
                } else {
                    # Handle DISM commands with real-time progress
                    $tempOutFile = [System.IO.Path]::GetTempFileName()
                    $tempErrFile = [System.IO.Path]::GetTempFileName()
                    $process = Start-Process -FilePath "dism" -ArgumentList ($cmd.Command -split " ") -NoNewWindow -RedirectStandardOutput $tempOutFile -RedirectStandardError $tempErrFile -PassThru
                    $lastPercentage = 0
                    while (-not $process.HasExited) {
                        Start-Sleep -Milliseconds 500
                        $output = Get-Content $tempOutFile -Raw -ErrorAction SilentlyContinue
                        if ($output) {
                            $lines = $output -split "`n"
                            foreach ($line in $lines) {
                                if ($line -match "\[\=+\s*(\d+\.\d+)%\s*\]") {
                                    $percentage = [double]$matches[1]
                                    if ($percentage -gt $lastPercentage) {
                                        $lastPercentage = $percentage
                                        Write-Progress -Activity $cmd.Description -PercentComplete $percentage -Status "Progress: $percentage%"
                                    }
                                }
                            }
                        }
                    }
                    $process.WaitForExit()
                    $output = Get-Content $tempOutFile -ErrorAction SilentlyContinue
                    $errorOutput = Get-Content $tempErrFile -ErrorAction SilentlyContinue
                    Remove-Item $tempOutFile
                    Remove-Item $tempErrFile

                    # Combine output and error for logging and display
                    $combinedOutput = $output
                    if ($errorOutput) {
                        $combinedOutput += $errorOutput
                    }

                    # Filter output for logging: exclude repetitive progress lines
                    $progressPattern = "\[\=+\s*\d+\.\d+%\s*\]"
                    $finalPercentage = $null
                    $filteredOutput = @()
                    foreach ($line in ($combinedOutput -split "`n")) {
                        if ($line -match $progressPattern) {
                            $finalPercentage = $line
                        } elseif ($line -and $line -notmatch $progressPattern) {
                            $filteredOutput += $line
                        }
                    }
                    if ($finalPercentage) {
                        $filteredOutput += $finalPercentage
                    }
                    $filteredOutput | Out-File -FilePath $logFile -Append
                    $filteredOutput | Write-Host

                    if ($cmd.Description -eq "CheckHealth - Check for component store corruption") {
                        if ($combinedOutput -match "No component store corruption detected") {
                            Write-Host "`nCheckHealth Result: No corruption detected" -ForegroundColor Green
                            Write-Log "CheckHealth: No component store corruption detected"
                            if (Confirm-Action -Message "No corruption found. Skip ScanHealth and RestoreHealth?" -Default "N") {
                                $skipScanHealth = $true
                                $skipRestoreHealth = $true
                            }
                        } else {
                            Write-Host "`nCheckHealth Result: Corruption detected" -ForegroundColor Yellow
                            Write-Log "CheckHealth: Component store corruption detected"
                            $osErrors++
                        }
                    } elseif ($cmd.Description -eq "ScanHealth - Perform a deeper scan for corruption") {
                        if ($combinedOutput -match "corrupt|error|failed") {
                            Write-Host "`nScanHealth Result: Corruption detected" -ForegroundColor Yellow
                            Write-Log "ScanHealth: Component store corruption detected"
                            $osErrors++
                        } else {
                            Write-Host "`nScanHealth Result: No corruption detected" -ForegroundColor Green
                            Write-Log "ScanHealth: No component store corruption detected"
                            if (Confirm-Action -Message "No corruption found in ScanHealth. Skip RestoreHealth?" -Default "N") {
                                $skipRestoreHealth = $true
                            }
                        }
                    } elseif ($cmd.Description -eq "RestoreHealth - Repair the component store") {
                        if ($combinedOutput -match "successfully repaired|restored") {
                            Write-Host "`nRestoreHealth Result: Repairs completed" -ForegroundColor Green
                            Write-Log "RestoreHealth: Component store repairs completed"
                            $osRepairs++
                        } elseif ($combinedOutput -match "corrupt|error|failed") {
                            Write-Host "`nRestoreHealth Result: Errors encountered" -ForegroundColor Yellow
                            Write-Log "RestoreHealth: Errors during repair"
                            $osErrors++
                        }
                    } elseif ($cmd.Description -eq "AnalyzeComponentStore - Analyze component store size") {
                        if ($combinedOutput -match "reclaimable.*: *0" -or $combinedOutput -notmatch "reclaim.*recommended") {
                            Write-Host "`nAnalyzeComponentStore Result: Cleanup not recommended" -ForegroundColor Green
                            Write-Log "AnalyzeComponentStore: Cleanup not recommended"
                            if (Confirm-Action -Message "Cleanup not recommended. Skip StartComponentCleanup?" -Default "N") {
                                $skipComponentCleanup = $true
                            }
                        } else {
                            Write-Host "`nAnalyzeComponentStore Result: Cleanup recommended" -ForegroundColor Yellow
                            Write-Log "AnalyzeComponentStore: Cleanup recommended"
                        }
                    } elseif ($cmd.Description -eq "StartComponentCleanup - Clean up superseded components") {
                        if ($combinedOutput -match "successfully completed") {
                            Write-Host "`nStartComponentCleanup Result: Cleanup completed" -ForegroundColor Green
                            Write-Log "StartComponentCleanup: Cleanup completed"
                            $osRepairs++
                        } elseif ($combinedOutput -match "error|failed") {
                            Write-Host "`nStartComponentCleanup Result: Errors encountered" -ForegroundColor Yellow
                            Write-Log "StartComponentCleanup: Errors during cleanup"
                            $osErrors++
                        }
                    }
                    Write-Progress -Activity $cmd.Description -Completed
                }
            } catch {
                Write-Log "Error executing $($cmd.Description): $_"
                Write-Host "`n$($cmd.Description) Result: Error - $_" -ForegroundColor Red
                $osErrors++
            }
            Write-Log "End of $($cmd.Description)"
        } else {
            Write-Log "Skipped: $($cmd.Description)"
        }
    }

    Write-Host "`nOS Maintenance Summary:" -ForegroundColor Green
    Write-Host "Errors Detected: $osErrors"
    Write-Host "Repairs Made: $osRepairs"
    if ($skipScanHealth -and $skipRestoreHealth) {
        Write-Host "Skipped ScanHealth and RestoreHealth due to no corruption in CheckHealth"
    } elseif ($skipRestoreHealth) {
        Write-Host "Skipped RestoreHealth due to no corruption in ScanHealth"
    }
    if ($skipComponentCleanup) {
        Write-Host "Skipped StartComponentCleanup as not recommended by AnalyzeComponentStore"
    }
    Write-Log "OS Maintenance Summary: Errors=$osErrors, Repairs=$osRepairs"
    if ($skipScanHealth -and $skipRestoreHealth) {
        Write-Log "Skipped ScanHealth and RestoreHealth due to no corruption in CheckHealth"
    }
    if ($skipRestoreHealth) {
        Write-Log "Skipped RestoreHealth due to no corruption in ScanHealth"
    }
    if ($skipComponentCleanup) {
        Write-Log "Skipped StartComponentCleanup as not recommended by AnalyzeComponentStore"
    }
} else {
    Write-Log "Skipped OS Maintenance section"
    Write-Host "`nOS Maintenance Summary: Skipped" -ForegroundColor Green
}

# Disk Maintenance Section
if (Confirm-Action -Message "Proceed with Disk Maintenance (CHKDSK, fsutil, Contig on all NTFS drives)?" -Default "Y") {
    $contigOutputs = @{}
    $dirtyVolumes = @()
    $lowSpaceDrives = @()
    $diskErrors = 0
    $diskRepairs = 0

    foreach ($drive in $ntfsDrives.DriveLetter) {
        $drivePath = "$drive`:"
        Write-Log "Processing disk maintenance for $drivePath..."

        $dirtyStatus = fsutil dirty query $drivePath
        if ($dirtyStatus -match "IS dirty") {
            Write-Log "$drivePath is marked dirty. Scheduling CHKDSK..."
            $dirtyVolumes += $drivePath
            chkdsk $drivePath /f
            $diskRepairs++
            Write-Host "`n$drivePath Status: Marked dirty, CHKDSK /f scheduled" -ForegroundColor Yellow
        } else {
            Write-Host "`n$drivePath Status: Not dirty" -ForegroundColor Green
        }

        $volumeInfo = Get-Volume -DriveLetter $drive
        if ($volumeInfo.SizeRemaining / $volumeInfo.Size -lt 0.1) {
            Write-Log "Low free space on $drivePath (<10%). Recommend cleanup."
            $lowSpaceDrives += $drivePath
            Write-Host "$drivePath Status: Low free space (<10%)" -ForegroundColor Yellow
        } else {
            Write-Host "$drivePath Status: Sufficient free space" -ForegroundColor Green
        }

        Write-Log "Checking corruption state of $drivePath with fsutil..."
        $repairState = fsutil repair state $drivePath
        $repairState | Out-File -FilePath $logFile -Append
        if ($repairState -match "0x00") {
            Write-Log "$drivePath is clean (0x00). No fsutil/chkdsk repair needed."
            Write-Host "$drivePath Status: Clean (0x00)" -ForegroundColor Green
        } else {
            Write-Log "$drivePath has corruption ($repairState). Initiating online repair..."
            fsutil repair initiate $drivePath
            Write-Log "Online repair initiated. Scheduling chkdsk /f /sdcleanup..."
            chkdsk $drivePath /f /sdcleanup
            Write-Log "chkdsk /f /sdcleanup scheduled. Reboot may be required."
            $diskRepairs++
            Write-Host "$drivePath Status: Corruption detected ($repairState), CHKDSK /f /sdcleanup scheduled" -ForegroundColor Yellow
            $diskErrors++
        }

        $chkdskScanCmd = "chkdsk /scan $drivePath"
        Write-Host "`nRunning CHKDSK Scan on $drivePath" -ForegroundColor Cyan
        if (Confirm-Action -Message "Proceed with CHKDSK Scan on $drivePath?" -Default "Y") {
            Write-Log "Executing: $chkdskScanCmd"
            $output = Invoke-Expression "$chkdskScanCmd 2>&1" | Tee-Object -FilePath $logFile -Append
            if ($output -match "found.*bad|corruption|error") {
                Write-Host "`nCHKDSK Scan Result: Errors found on $drivePath" -ForegroundColor Yellow
                Write-Log "CHKDSK Scan: Errors found on $drivePath"
                $diskErrors++
            } else {
                Write-Host "`nCHKDSK Scan Result: No errors found on $drivePath" -ForegroundColor Green
                Write-Log "CHKDSK Scan: No errors found on $drivePath"
            }
            Write-Log "End of CHKDSK Scan on $drivePath"
        } else {
            Write-Log "Skipped CHKDSK Scan on $drivePath"
            Write-Host "`nCHKDSK Scan Result: Skipped for $drivePath" -ForegroundColor Green
        }

        if ($contigAvailable) {
            $contigCmd = "contig -v -accepteula $drivePath\`$MFT"
            Write-Host "`nRunning Contig on MFT for $drivePath" -ForegroundColor Cyan
            if (Confirm-Action -Message "Proceed with Contig on MFT for $drivePath?" -Default "Y") {
                Write-Log "Executing: $contigCmd"
                $output = Invoke-Expression "$contigCmd 2>&1" | Tee-Object -FilePath $logFile -Append
                $contigOutputs[$drivePath] = $output
                $fragmentMatch = $output | Select-String "is in (\d+) fragments"
                $fragments = if ($fragmentMatch) { [int]$fragmentMatch.Matches.Groups[1].Value } else { 0 }
                if ($output -match "error|failed|cannot open") {
                    Write-Host "`nContig Result: Errors encountered on $drivePath" -ForegroundColor Yellow
                    Write-Log "Contig: Errors encountered on $drivePath"
                    $diskErrors++
                } else {
                    Write-Host "`nContig Result: MFT on $drivePath in $fragments fragments" -ForegroundColor Green
                    Write-Log "Contig: MFT on $drivePath in $fragments fragments"
                }
                Write-Log "End of Contig on $drivePath"
            } else {
                Write-Log "Skipped Contig on $drivePath"
                Write-Host "`nContig Result: Skipped for $drivePath" -ForegroundColor Green
            }
        } else {
            Write-Log "Contig not available. Skipping MFT defragmentation for $drivePath."
            Write-Host "`nContig Result: Skipped for $drivePath (Contig not available)" -ForegroundColor Yellow
        }
    }

    Write-Host "`nDisk Maintenance Summary:" -ForegroundColor Green
    Write-Host "Dirty Volumes: $($dirtyVolumes -join ', ')"
    Write-Host "Low Space Drives: $($lowSpaceDrives -join ', ')"
    Write-Host "Errors Detected: $diskErrors"
    Write-Host "Repairs/Scheduled Fixes: $diskRepairs"
    if ($dirtyVolumes.Count -gt 0) {
        Write-Host "Reboot required to complete CHKDSK fixes on: $($dirtyVolumes -join ', ')" -ForegroundColor Yellow
    }
    Write-Log "Disk Maintenance Summary: Dirty Volumes=$($dirtyVolumes -join ', '), Low Space Drives=$($lowSpaceDrives -join ', '), Errors=$diskErrors, Repairs=$diskRepairs"
    if ($dirtyVolumes.Count -gt 0) {
        Write-Log "Reboot required to complete CHKDSK fixes on: $($dirtyVolumes -join ', ')"
    }
} else {
    Write-Log "Skipped Disk Maintenance section"
    Write-Host "`nDisk Maintenance Summary: Skipped" -ForegroundColor Green
}

# Shadow Copy Maintenance Section
if (Confirm-Action -Message "Proceed with Shadow Copy Maintenance (check and fix corruption on all NTFS drives)?" -Default "Y") {
    $shadowStates = @{}
    $corruptedShadows = 0
    $shadowsDeleted = 0
    $restorePointCreated = $false

    foreach ($drive in $ntfsDrives.DriveLetter) {
        $drivePath = "$drive`:"
        Write-Log "Processing shadow copy maintenance for $drivePath..."

        $shadowList = vssadmin list shadows /for=$drivePath
        $shadowList | Out-File -FilePath $logFile -Append
        $shadowCopies = $shadowList | Select-String "Shadow Copy ID: {(.+?)}" | ForEach-Object { $_.Matches.Groups[1].Value }
        $shadowVolumes = $shadowList | Select-String "Shadow Copy Volume: (.+?)$" | ForEach-Object { $_.Matches.Groups[1].Value }

        if ($shadowCopies) {
            Write-Log "Found $($shadowCopies.Count) shadow copies for $drivePath."
            Write-Host "`n$drivePath Shadow Copies: Found $($shadowCopies.Count)" -ForegroundColor Green
            $driveShadowStates = @()
            for ($i = 0; $i -lt $shadowCopies.Count; $i++) {
                $shadowId = $shadowCopies[$i]
                $shadowVolume = $shadowVolumes[$i]
                Write-Log "Checking corruption state of shadow copy: $shadowVolume (ID: $shadowId)"
                $shadowRepairState = fsutil repair state $shadowVolume
                $shadowRepairState | Out-File -FilePath $logFile -Append
                $driveShadowStates += $shadowRepairState
                if ($shadowRepairState -match "0x00") {
                    Write-Log "Shadow copy $shadowVolume is clean (0x00)."
                    Write-Host "Shadow Copy ${shadowVolume}: Clean (0x00)" -ForegroundColor Green
                } else {
                    Write-Log "Shadow copy $shadowVolume is corrupted ($shadowRepairState). Deleting..."
                    vssadmin delete shadows /shadow=$shadowId /quiet
                    Write-Log "Deleted corrupted shadow copy $shadowId for $drivePath."
                    Write-Host "Shadow Copy ${shadowVolume}: Corrupted ($shadowRepairState), deleted" -ForegroundColor Yellow
                    $corruptedShadows++
                    $shadowsDeleted++
                }
            }
            $shadowStates[$drivePath] = $driveShadowStates
        } else {
            Write-Log "No shadow copies found for $drivePath."
            Write-Host "`n$drivePath Shadow Copies: None found" -ForegroundColor Green
        }
    }

    if ($ntfsDrives.DriveLetter -contains "C" -and ($shadowStates.Values | ForEach-Object { $_ | Select-String "0x00" -NotMatch })) {
        Write-Log "Creating new restore point for C:..."
        try {
            Checkpoint-Computer -Description "Post-ShadowCopyCleanup Restore Point $((Get-Date -Format 'yyyy-MM-dd HH:mm:ss'))" -RestorePointType MODIFY_SETTINGS
            Write-Log "New restore point created successfully for C:."
            Write-Host "`nC: Restore Point: Created successfully" -ForegroundColor Green
            $restorePointCreated = $true
        } catch {
            Write-Log "Error creating restore point for C:: $_"
            Write-Host "`nC: Restore Point: Error - $_" -ForegroundColor Red
        }
    }

    Write-Host "`nShadow Copy Maintenance Summary:" -ForegroundColor Green
    Write-Host "Corrupted Shadow Copies: $corruptedShadows"
    Write-Host "Shadow Copies Deleted: $shadowsDeleted"
    Write-Host "New Restore Point for C: $(if ($restorePointCreated) { 'Created' } else { 'Not created' })"
    Write-Log "Shadow Copy Maintenance Summary: Corrupted Shadows=$corruptedShadows, Shadows Deleted=$shadowsDeleted, Restore Point Created=$($restorePointCreated)"
} else {
    Write-Log "Skipped Shadow Copy Maintenance section"
    Write-Host "`nShadow Copy Maintenance Summary: Skipped" -ForegroundColor Green
}

# Optimization Section
if (Confirm-Action -Message "Proceed with Drive Optimization (defrag /C /O /V for SSDs, prompt for non-SSDs)?" -Default "Y") {
    $defragErrors = 0
    $defragOptimizations = 0
    Write-Log "Checking drive types for optimization..."
    if ($ssdDrives) {
        Write-Log "Running defrag /C /O /V for SSD drives: $($ssdDrives -join ', ')"
        $defragOutput = defrag /C /O /V 2>&1
        $defragOutput | Out-File -FilePath $logFile -Append
        if ($defragOutput -match "optimized|trimmed") {
            Write-Host "`nSSD Optimization Result: TRIM completed for $($ssdDrives -join ', ')" -ForegroundColor Green
            Write-Log "SSD optimization (TRIM) completed."
            $defragOptimizations++
        } elseif ($defragOutput -match "error|failed") {
            Write-Host "`nSSD Optimization Result: Errors encountered" -ForegroundColor Yellow
            Write-Log "SSD optimization: Errors encountered"
            $defragErrors++
        }
    }
    if ($nonSsdDrives) {
        Write-Log "Non-SSD drives detected: $($nonSsdDrives -join ', '). Defragmentation may take significant time."
        if (Confirm-Action -Message "Proceed with defrag /C /O /V for non-SSD drives (may be time-consuming)?" -Default "N") {
            Write-Log "Running defrag /C /O /V for non-SSD drives..."
            $defragOutput = defrag /C /O /V 2>&1
            $defragOutput | Out-File -FilePath $logFile -Append
            if ($defragOutput -match "defragmented") {
                Write-Host "`nNon-SSD Optimization Result: Defragmentation completed for $($nonSsdDrives -join ', ')" -ForegroundColor Green
                Write-Log "Non-SSD defragmentation completed."
                $defragOptimizations++
            } elseif ($defragOutput -match "error|failed") {
                Write-Host "`nNon-SSD Optimization Result: Errors encountered" -ForegroundColor Yellow
                Write-Log "Non-SSD defragmentation: Errors encountered"
                $defragErrors++
            }
        } else {
            Write-Log "Skipped defragmentation for non-SSD drives."
            Write-Host "`nNon-SSD Optimization Result: Skipped for $($nonSsdDrives -join ', ')" -ForegroundColor Green
        }
    }
    if (-not $ssdDrives -and -not $nonSsdDrives) {
        Write-Log "No drives eligible for optimization."
        Write-Host "`nDrive Optimization Result: No eligible drives" -ForegroundColor Green
    }

    Write-Host "`nDrive Optimization Summary:" -ForegroundColor Green
    Write-Host "Errors Detected: $defragErrors"
    Write-Host "Optimizations Performed: $defragOptimizations"
    Write-Log "Drive Optimization Summary: Errors=$defragErrors, Optimizations=$defragOptimizations"
} else {
    Write-Log "Skipped Drive Optimization section"
    Write-Host "`nDrive Optimization Summary: Skipped" -ForegroundColor Green
}

# Temp File Cleanup Section
if (Confirm-Action -Message "Proceed with Temp File Cleanup (system/user temp, Windows Update cache)?" -Default "Y") {
    Write-Log "Starting Temp File Cleanup..."
    $totalBytesFreed = 0
    $cleanupErrors = 0

    function Get-FolderSize {
        param($Path)
        try {
            if (Test-Path $Path) {
                $size = (Get-ChildItem $Path -Recurse -File -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum -ErrorAction SilentlyContinue).Sum
                return [math]::Round($size / 1MB, 2)
            }
            return 0
        } catch {
            Write-Log "Error calculating size for ${Path}: $_"
            Write-Host "`nFolder Size Calculation Result for ${Path}: Error - $_" -ForegroundColor Red
            return 0
        }
    }

    $sysTempPath = "C:\Windows\Temp"
    Write-Log "Cleaning $sysTempPath..."
    $beforeSize = Get-FolderSize -Path $sysTempPath
    try {
        Get-ChildItem $sysTempPath -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        $afterSize = Get-FolderSize -Path $sysTempPath
        $freed = $beforeSize - $afterSize
        $totalBytesFreed += $freed
        Write-Log "Freed $freed MB from $sysTempPath"
        Write-Host "`nSystem Temp Cleanup Result: Freed $freed MB from $sysTempPath" -ForegroundColor Green
    } catch {
        Write-Log "Error cleaning ${sysTempPath}: $_"
        Write-Host "`nSystem Temp Cleanup Result: Error cleaning ${sysTempPath} - $_" -ForegroundColor Red
        $cleanupErrors++
    }

    $userTempPath = $env:TEMP
    Write-Log "Cleaning $userTempPath..."
    $beforeSize = Get-FolderSize -Path $userTempPath
    try {
        Get-ChildItem $userTempPath -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        $afterSize = Get-FolderSize -Path $userTempPath
        $freed = $beforeSize - $afterSize
        $totalBytesFreed += $freed
        Write-Log "Freed $freed MB from $userTempPath"
        Write-Host "`nUser Temp Cleanup Result: Freed $freed MB from $userTempPath" -ForegroundColor Green
    } catch {
        Write-Log "Error cleaning ${userTempPath}: $_"
        Write-Host "`nUser Temp Cleanup Result: Error cleaning ${userTempPath} - $_" -ForegroundColor Red
        $cleanupErrors++
    }

    $updatePath = "C:\Windows\SoftwareDistribution\Download"
    Write-Log "Cleaning Windows Update cache ($updatePath)..."
    try {
        Stop-Service -Name wuauserv -Force -ErrorAction SilentlyContinue
        $beforeSize = Get-FolderSize -Path $updatePath
        Get-ChildItem $updatePath -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        $afterSize = Get-FolderSize -Path $updatePath
        $freed = $beforeSize - $afterSize
        $totalBytesFreed += $freed
        Write-Log "Freed $freed MB from $updatePath"
        Write-Host "`nWindows Update Cache Cleanup Result: Freed $freed MB from $updatePath" -ForegroundColor Green
        Start-Service -Name wuauserv -ErrorAction SilentlyContinue
    } catch {
        Write-Log "Error cleaning ${updatePath}: $_"
        Write-Host "`nWindows Update Cache Cleanup Result: Error cleaning ${updatePath} - $_" -ForegroundColor Red
        $cleanupErrors++
        Start-Service -Name wuauserv -ErrorAction SilentlyContinue
    }

    Write-Log "Temp File Cleanup completed. Total freed: $totalBytesFreed MB, Errors: $cleanupErrors"
    Write-Host "`nTemp File Cleanup Summary:" -ForegroundColor Green
    Write-Host "Total Space Freed: $totalBytesFreed MB"
    Write-Host "Errors Encountered: $cleanupErrors"
} else {
    Write-Log "Skipped Temp File Cleanup"
    Write-Host "`nTemp File Cleanup Summary: Skipped" -ForegroundColor Green
}

# Hardware and Driver Checks Section
if (Confirm-Action -Message "Proceed with Hardware and Driver Checks (SMART, drivers)?" -Default "Y") {
    $physicalDisks = Get-PhysicalDisk
    $reliability = $physicalDisks | Get-StorageReliabilityCounter
    $smartIssues = 0
    foreach ($disk in $physicalDisks) {
        if ($disk.HealthStatus -ne "Healthy") {
            Write-Log "Unhealthy disk: $($disk.DeviceId) - Status: $($disk.HealthStatus)"
            Write-Host "`nDisk $($disk.DeviceId) Status: Unhealthy - $($disk.HealthStatus)" -ForegroundColor Yellow
            $smartIssues++
        } else {
            Write-Host "`nDisk $($disk.DeviceId) Status: Healthy" -ForegroundColor Green
        }
    }
    foreach ($counter in $reliability) {
        if ($counter.ReadErrorsTotal -gt 0 -or $counter.WriteErrorsTotal -gt 0 -or $counter.Wear -gt 90) {
            Write-Log "SMART issues on disk: ReadErrors=$($counter.ReadErrorsTotal), WriteErrors=$($counter.WriteErrorsTotal), Wear=$($counter.Wear)%"
            Write-Host "Disk SMART Issues: ReadErrors=$($counter.ReadErrorsTotal), WriteErrors=$($counter.WriteErrorsTotal), Wear=$($counter.Wear)%" -ForegroundColor Yellow
            $smartIssues++
        }
    }

    $problemDrivers = Get-WmiObject Win32_PnPSignedDriver | Where-Object { $_.Status -ne "OK" -or -not $_.IsSigned }
    $driverIssues = if ($problemDrivers) { $problemDrivers.Count } else { 0 }
    if ($problemDrivers) {
        Write-Log "Problem drivers found: $($problemDrivers.Count). Running pnputil /scan-devices..."
        Write-Host "`nDriver Check Result: $driverIssues problem drivers found, running pnputil /scan-devices" -ForegroundColor Yellow
        pnputil /scan-devices
    } else {
        Write-Host "`nDriver Check Result: No problem drivers found" -ForegroundColor Green
        Write-Log "No problem drivers found."
    }

    Write-Host "`nHardware and Driver Checks Summary:" -ForegroundColor Green
    Write-Host "SMART Issues: $smartIssues"
    Write-Host "Problem Drivers: $driverIssues"
    if ($smartIssues -gt 0) {
        Write-Host "Recommendation: Run full hardware diagnostics (e.g., CrystalDiskInfo)" -ForegroundColor Yellow
    }
    Write-Log "Hardware and Driver Checks Summary: SMART Issues=$smartIssues, Problem Drivers=$driverIssues"
} else {
    Write-Log "Skipped Hardware and Driver Checks"
    Write-Host "`nHardware and Driver Checks Summary: Skipped" -ForegroundColor Green
}

# Memory and Update Checks Section
if (Confirm-Action -Message "Proceed with Memory and Update Checks?" -Default "Y") {
    $failedUpdates = Get-HotFix | Where-Object { $_.Status -ne "Succeeded" }
    $failedUpdateCount = if ($failedUpdates) { $failedUpdates.Count } else { 0 }
    $memoryDiagnosticScheduled = $false

    if ($failedUpdates) {
        Write-Log "Failed updates found: $($failedUpdates.Count). Running wuauclt /detectnow..."
        Write-Host "`nUpdate Check Result: $failedUpdateCount failed updates found, running wuauclt /detectnow" -ForegroundColor Yellow
        wuauclt /detectnow
    } else {
        Write-Host "`nUpdate Check Result: No failed updates found" -ForegroundColor Green
        Write-Log "No failed updates found."
    }

    if (Confirm-Action -Message "Schedule Windows Memory Diagnostic on next reboot?" -Default "N") {
        mdsched.exe /scheduleboot
        Write-Log "Memory Diagnostic scheduled on next reboot."
        Write-Host "`nMemory Diagnostic Result: Scheduled for next reboot" -ForegroundColor Green
        $memoryDiagnosticScheduled = $true
    } else {
        Write-Host "`nMemory Diagnostic Result: Not scheduled" -ForegroundColor Green
    }

    Write-Host "`nMemory and Update Checks Summary:" -ForegroundColor Green
    Write-Host "Failed Updates: $failedUpdateCount"
    Write-Host "Memory Diagnostic: $(if ($memoryDiagnosticScheduled) { 'Scheduled' } else { 'Not scheduled' })"
    Write-Log "Memory and Update Checks Summary: Failed Updates=$failedUpdateCount, Memory Diagnostic=$($memoryDiagnosticScheduled)"
} else {
    Write-Log "Skipped Memory and Update Checks"
    Write-Host "`nMemory and Update Checks Summary: Skipped" -ForegroundColor Green
}

# Malware Scan Section
if (Confirm-Action -Message "Proceed with Quick Malware Scan (Windows Defender)?" -Default "Y") {
    Write-Log "Checking Windows Defender service status..."
    $defenderService = Get-Service -Name WinDefend -ErrorAction SilentlyContinue
    $thirdPartyAV = Get-CimInstance -Namespace "root/SecurityCenter2" -ClassName AntiVirusProduct -ErrorAction SilentlyContinue
    $defenderEnabled = $true
    $defenderRecommendations = @()

    if ($thirdPartyAV) {
        Write-Log "Third-party antivirus detected: $($thirdPartyAV.displayName -join ', ')"
        Write-Host "`nThird-party antivirus detected: $($thirdPartyAV.displayName -join ', ')" -ForegroundColor Yellow
        Write-Log "Windows Defender may be disabled due to third-party antivirus."
        Write-Host "Windows Defender may be disabled due to third-party antivirus." -ForegroundColor Yellow
        $defenderEnabled = $false
        $defenderRecommendations += "Verify third-party antivirus status or temporarily disable it to use Windows Defender."
    }

    if ($defenderService) {
        if ($defenderService.Status -ne "Running") {
            Write-Log "Windows Defender service (WinDefend) is not running. Attempting to start..."
            Write-Host "`nWindows Defender Service Status: Not running, attempting to start..." -ForegroundColor Yellow
            try {
                Start-Service -Name WinDefend -ErrorAction Stop
                Write-Log "Windows Defender service started successfully."
                Write-Host "Windows Defender Service Status: Started" -ForegroundColor Green
            } catch {
                Write-Log "Failed to start Windows Defender service: $_"
                Write-Host "Windows Defender Service Status: Failed to start - $_" -ForegroundColor Red
                $defenderEnabled = $false
                $defenderRecommendations += "Manually check Windows Defender service status in services.msc or reinstall Defender components."
            }
        } else {
            Write-Log "Windows Defender service (WinDefend) is running."
            Write-Host "`nWindows Defender Service Status: Running" -ForegroundColor Green
        }
    } else {
        Write-Log "Windows Defender service (WinDefend) not found."
        Write-Host "`nWindows Defender Service Status: Not found" -ForegroundColor Red
        $defenderEnabled = $false
        $defenderRecommendations += "Reinstall Windows Defender or check for system corruption."
    }

    if ($defenderEnabled) {
        Write-Log "Running Quick Malware Scan..."
        Write-Host "`nRunning Quick Malware Scan..." -ForegroundColor Cyan
        try {
            Start-MpScan -ScanType QuickScan -ErrorAction Stop
            $defenderEvents = Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=@(1000,1001); StartTime=(Get-Date).AddHours(-1)} -ErrorAction SilentlyContinue
            $threats = $defenderEvents | Where-Object { $_.Message -match "threat detected" }
            $threatCount = if ($threats) { $threats.Count } else { 0 }
            if ($threats) {
                Write-Log "Threats detected: $threatCount. Recommend full scan."
                Write-Host "`nMalware Scan Result: $threatCount threats detected, recommend full scan" -ForegroundColor Yellow
                $defenderRecommendations += "Run a full Windows Defender scan (Start-MpScan -ScanType FullScan) or review threats in Defender UI."
            } else {
                Write-Log "No threats found in quick scan."
                Write-Host "`nMalware Scan Result: No threats found" -ForegroundColor Green
            }
        } catch {
            Write-Log "Error running Quick Malware Scan: $_"
            Write-Host "`nMalware Scan Result: Error - $_" -ForegroundColor Red
            $defenderRecommendations += "Run MpCmdRun -SignatureUpdate to update Defender definitions, or check for system corruption with DISM/SFC."
        }
    } else {
        Write-Log "Skipped Quick Malware Scan due to Defender being disabled or unavailable."
        Write-Host "`nMalware Scan Result: Skipped due to Defender being disabled or unavailable" -ForegroundColor Yellow
        $defenderRecommendations += "Enable Windows Defender via gpedit.msc (Computer Configuration > Administrative Templates > Windows Components > Microsoft Defender Antivirus) or remove conflicting antivirus software."
    }

    Write-Host "`nMalware Scan Summary:" -ForegroundColor Green
    Write-Host "Defender Enabled: $(if ($defenderEnabled) { 'Yes' } else { 'No' })"
    Write-Host "Threats Detected: $(if ($defenderEnabled) { $threatCount } else { 'N/A' })"
    if ($defenderRecommendations) {
        Write-Host "Recommendations:" -ForegroundColor Yellow
        $defenderRecommendations | ForEach-Object { Write-Host "- $_" }
        $defenderRecommendations | ForEach-Object { Write-Log "Recommendation: $_" }
    }
    Write-Log "Malware Scan Summary: Defender Enabled=$($defenderEnabled), Threats Detected=$(if ($defenderEnabled) { $threatCount } else { 'N/A' })"
} else {
    Write-Log "Skipped Malware Scan"
    Write-Host "`nMalware Scan Summary: Skipped" -ForegroundColor Green
}

# Verify VSS service
Write-Log "Checking Volume Shadow Copy Service (VSS) status..."
$vssStatus = Get-Service -Name VSS
if ($vssStatus.Status -eq "Running") {
    Write-Log "VSS service is running."
    Write-Host "`nVSS Service Status: Running" -ForegroundColor Green
} else {
    Write-Log "VSS service is not running. Starting VSS..."
    Start-Service -Name VSS
    Write-Log "VSS service started."
    Write-Host "`nVSS Service Status: Started" -ForegroundColor Green
}

# Log and Event Log Analysis Section
if (Confirm-Action -Message "Proceed with expanded log analysis?" -Default "Y") {
    $dismLogPath = "$env:windir\Logs\DISM\dism.log"
    $cbsLogPath = "$env:windir\Logs\CBS\cbs.log"
    
    $dismErrors = 0
    $dismRepairs = 0
    $cbsErrors = 0
    $cbsRepairs = 0
    $chkdskErrors = 0
    $chkdskRepairs = 0
    $contigErrorsPerDrive = @{}
    $contigFragmentsPerDrive = @{}
    $fsutilCorruptedDrives = 0
    $shadowCorrupted = 0
    $defragErrors = 0
    $defragOptimizations = 0
    $diskErrors = 0
    $driverErrors = 0
    $hardwareErrors = 0
    $vssErrors = 0
    $cleanupErrors = 0
    $totalBytesFreed = 0
    $defenderErrors = 0
    
    $errorPattern = "error|failed|failure|corrupt"
    $repairPattern = "repaired|restored|fixed|successfully repaired"
    $chkdskErrorPattern = "found \d+ bad|corruption|error"
    $chkdskRepairPattern = "repaired|fixed|corrected|cleaned"
    $contigErrorPattern = "error|failed|cannot open"
    $contigFragmentPattern = "is in (\d+) fragments"
    $fsutilCorruptionPattern = "0x[1-9A-F]"
    $shadowCorruptionPattern = "0x[1-9A-F]"
    $defragErrorPattern = "error|failed"
    $defragOptPattern = "optimized|trimmed|defragmented"
    $cleanupErrorPattern = "Error cleaning.*Temp|SoftwareDistribution"
    $defenderErrorPattern = "Error running Quick Malware Scan"
    
    if (Test-Path $dismLogPath) {
        $dismErrors = (Select-String -Path $dismLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $dismRepairs = (Select-String -Path $dismLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
    } else {
        Write-Log "DISM.log not found at $dismLogPath"
    }
    
    if (Test-Path $cbsLogPath) {
        $cbsErrors = (Select-String -Path $cbsLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $cbsRepairs = (Select-String -Path $cbsLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
    } else {
        Write-Log "CBS.log not found at $cbsLogPath"
    }
    
    $eventIds = @(7,11,50,55,98,137,140,153,219,41,7023,2004,1001,12289,12290)
    $systemEvents = Get-WinEvent -FilterHashtable @{LogName='System'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $appEvents = Get-WinEvent -FilterHashtable @{LogName='Application'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $allEvents = $systemEvents + $appEvents

    $diskErrors = $allEvents | Where-Object { $_.Id -in @(7,11,50,55,98,137,140,153) } | Measure-Object | Select -Expand Count
    $driverErrors = $allEvents | Where-Object { $_.Id -in @(219,7023) } | Measure-Object | Select -Expand Count
    $hardwareErrors = $allEvents | Where-Object { $_.Id -in @(41,2004,1001) } | Measure-Object | Select -Expand Count
    $vssErrors = $allEvents | Where-Object { $_.Id -in @(12289,12290) } | Measure-Object | Select -Expand Count
    
    foreach ($drivePath in $contigOutputs.Keys) {
        $output = $contigOutputs[$drivePath]
        $contigErrorsPerDrive[$drivePath] = ($output | Select-String -Pattern $contigErrorPattern -CaseSensitive:$false | Measure-Object).Count
        $fragmentMatch = $output | Select-String -Pattern $contigFragmentPattern -CaseSensitive:$false
        if ($fragmentMatch) {
            $contigFragmentsPerDrive[$drivePath] = [int]($fragmentMatch.Matches.Groups[1].Value)
        } else {
            $contigFragmentsPerDrive[$drivePath] = 0
        }
    }
    
    $fsutilCorruptedDrives = (Select-String -Path $logFile -Pattern $fsutilCorruptionPattern | Measure-Object).Count
    foreach ($states in $shadowStates.Values) {
        $shadowCorrupted += ($states | Select-String -Pattern $shadowCorruptionPattern | Measure-Object).Count
    }
    $defragErrors = (Select-String -Path $logFile -Pattern $defragErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $defragOptimizations = (Select-String -Path $logFile -Pattern $defragOptPattern -CaseSensitive:$false | Measure-Object).Count
    $cleanupErrors = (Select-String -Path $logFile -Pattern $cleanupErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $defenderErrors = (Select-String -Path $logFile -Pattern $defenderErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $totalBytesFreed = ($logFile | Select-String "Freed (\d+\.?\d*) MB" | ForEach-Object { [double]$_.Matches.Groups[1].Value } | Measure-Object -Sum).Sum
    
    Write-Host "`nLog Analysis Summary:" -ForegroundColor Green
    Write-Host "Pending Updates: $pendingUpdates"
    Write-Host "Pending Restarts: $($pendingRestartSources -join ', ')"
    Write-Host "DISM.log Errors/Failures: $dismErrors"
    Write-Host "DISM.log Repairs: $dismRepairs"
    Write-Host "CBS.log Errors/Failures: $cbsErrors"
    Write-Host "CBS.log Repairs: $cbsRepairs"
    Write-Host "CHKDSK Event Log Errors: $chkdskErrors"
    Write-Host "CHKDSK Event Log Repairs: $chkdskRepairs"
    foreach ($drivePath in $contigErrorsPerDrive.Keys) {
        $driveType = ($ntfsDrives | Where-Object { $_.DriveLetter -eq $drivePath[0] }).MediaType
        Write-Host "Contig Errors on $drivePath ($driveType): $($contigErrorsPerDrive[$drivePath])"
        Write-Host "Contig MFT Fragments on $drivePath ($driveType): $($contigFragmentsPerDrive[$drivePath])"
    }
    Write-Host "fsutil Corrupted Drives: $fsutilCorruptedDrives"
    Write-Host "Shadow Copy Corrupted Instances: $shadowCorrupted"
    Write-Host "Defrag Errors: $defragErrors"
    Write-Host "Defrag Optimizations: $defragOptimizations"
    Write-Host "Temp File Cleanup Errors: $cleanupErrors"
    Write-Host "Temp File Cleanup Freed (MB): $totalBytesFreed"
    Write-Host "Disk/NTFS Errors (IDs 7,11,50,55,98,137,140,153): $diskErrors"
    Write-Host "Driver Errors (IDs 219,7023): $driverErrors"
    Write-Host "Hardware/Memory Errors (IDs 41,2004,1001): $hardwareErrors"
    Write-Host "VSS Errors (IDs 12289,12290): $vssErrors"
    Write-Host "Defender Errors: $defenderErrors"

    $recommendations = @()
    if ($pendingUpdates -gt 0) { $recommendations += "Install $pendingUpdates pending updates via Windows Update or PSWindowsUpdate (Install-WUUpdates)." }
    if ($pendingRestartSources) { $recommendations += "Restart system to apply pending changes ($($pendingRestartSources -join ', '))." }
    if ($diskErrors -gt 0) { $recommendations += "Run full CHKDSK /f /r on affected drives (caution on SSDs)." }
    if ($smartIssues -gt 0) { $recommendations += "Check hardware with manufacturer tools (e.g., CrystalDiskInfo)." }
    if ($driverErrors -gt 0) { $recommendations += "Update or rollback drivers via Device Manager." }
    if ($hardwareErrors -gt 0) { $recommendations += "Run memory/hardware diagnostics." }
    if ($vssErrors -gt 0) { $recommendations += "Restart VSS service or clear shadow storage." }
    if ($lowSpaceDrives.Count -gt 0) { $recommendations += "Free up space on $($lowSpaceDrives -join ', ')." }
    if ($threats) { $recommendations += "Run full Defender scan." }
    if ($totalBytesFreed -gt 1000) { $recommendations += "Significant temp files cleared ($totalBytesFreed MB). Consider scheduling regular cleanups." }
    if ($cleanupErrors -gt 0) { $recommendations += "Temp file cleanup encountered errors. Check log for details." }
    if ($defenderErrors -gt 0) { $recommendations += "Check Windows Defender status in services.msc, run MpCmdRun -SignatureUpdate, or repair system with DISM/SFC." }
    if ($failedUpdateCount -gt 0) { $recommendations += "Troubleshoot $failedUpdateCount failed updates using Windows Update Troubleshooter or DISM/SFC." }
    if ($recommendations) {
        Write-Host "Recommendations:" -ForegroundColor Yellow
        $recommendations | ForEach-Object { Write-Host "- $_" }
    }

    "----- Log Analysis Summary at $(Get-Date) -----" | Out-File -FilePath $logFile -Append
    "Pending Updates: $pendingUpdates" | Out-File -FilePath $logFile -Append
    "Pending Restarts: $($pendingRestartSources -join ', ')" | Out-File -FilePath $logFile -Append
    "DISM.log Errors/Failures: $dismErrors" | Out-File -FilePath $logFile -Append
    "DISM.log Repairs: $dismRepairs" | Out-File -FilePath $logFile -Append
    "CBS.log Errors/Failures: $cbsErrors" | Out-File -FilePath $logFile -Append
    "CBS.log Repairs: $cbsRepairs" | Out-File -FilePath $logFile -Append
    "CHKDSK Event Log Errors: $chkdskErrors" | Out-File -FilePath $logFile -Append
    "CHKDSK Event Log Repairs: $chkdskRepairs" | Out-File -FilePath $logFile -Append
    foreach ($drivePath in $contigErrorsPerDrive.Keys) {
        $driveType = ($ntfsDrives | Where-Object { $_.DriveLetter -eq $drivePath[0] }).MediaType
        "Contig Errors on $drivePath ($driveType): $($contigErrorsPerDrive[$drivePath])" | Out-File -FilePath $logFile -Append
        "Contig MFT Fragments on $drivePath ($driveType): $($contigFragmentsPerDrive[$drivePath])" | Out-File -FilePath $logFile -Append
    }
    "fsutil Corrupted Drives: $fsutilCorruptedDrives" | Out-File -FilePath $logFile -Append
    "Shadow Copy Corrupted Instances: $shadowCorrupted" | Out-File -FilePath $logFile -Append
    "Defrag Errors: $defragErrors" | Out-File -FilePath $logFile -Append
    "Defrag Optimizations: $defragOptimizations" | Out-File -FilePath $logFile -Append
    "Temp File Cleanup Errors: $cleanupErrors" | Out-File -FilePath $logFile -Append
    "Temp File Cleanup Freed (MB): $totalBytesFreed" | Out-File -FilePath $logFile -Append
    "Disk/NTFS Errors (IDs 7,11,50,55,98,137,140,153): $diskErrors" | Out-File -FilePath $logFile -Append
    "Driver Errors (IDs 219,7023): $driverErrors" | Out-File -FilePath $logFile -Append
    "Hardware/Memory Errors (IDs 41,2004,1001): $hardwareErrors" | Out-File -FilePath $logFile -Append
    "VSS Errors (IDs 12289,12290): $vssErrors" | Out-File -FilePath $logFile -Append
    "Defender Errors: $defenderErrors" | Out-File -FilePath $logFile -Append
    if ($recommendations) {
        "Recommendations:" | Out-File -FilePath $logFile -Append
        $recommendations | ForEach-Object { "- $_" | Out-File -FilePath $logFile -Append }
    }
    "----- End of Log Analysis -----" | Out-File -FilePath $logFile -Append
} else {
    Write-Log "Skipped Log Analysis"
    Write-Host "`nLog Analysis Summary: Skipped" -ForegroundColor Green
}

Write-Host "`nAll operations completed. Log file: $logFile" -ForegroundColor Cyan
pause