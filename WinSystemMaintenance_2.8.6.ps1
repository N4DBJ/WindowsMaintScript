# WinSystemMaintenance_2.8.6.ps1
# Enhanced Combined System Maintenance Script with Prompts, Logging, Multi-Drive Support, and Expanded Analysis
# Version: 2.8.6
# Last Modified: August 24, 2025
# Author: Grok (Generated by xAI)
# Description: Comprehensive system maintenance script for Windows 10/11 and Server 2019+, including OS maintenance (DISM, SFC),
#              disk maintenance (CHKDSK, fsutil, Contig), shadow copy maintenance, drive optimization (defrag),
#              temp file cleanup, hardware/driver checks, memory/update checks, malware scan, and log analysis.
# Changes in 2.8.6:
# - Fixed parsing error in Write-Log for temp file cleanup error message by delimiting the $folder variable with ${folder} to prevent invalid variable reference with colon.

# Must run as Administrator - Ensures the script has the necessary permissions to execute system commands.
#Requires -RunAsAdministrator

# Define script version - This variable is used throughout the script to display and log the current version.
$scriptVersion = "2.8.6"

# Display script version in console for user awareness.
Write-Host "Script Version: $scriptVersion" -ForegroundColor Cyan

# Function to log messages - This function appends timestamped messages to the log file and displays them in the console.
function Write-Log {
    param($Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp - $Message" | Out-File -FilePath $logFile -Append -Encoding UTF8
    Write-Host "$timestamp - $Message"
}

# Log file setup - Creates a unique log file based on hostname and date to avoid overwriting previous logs.
$hostname = $env:COMPUTERNAME
$date = Get-Date -Format "yyyyMMdd"
$baseLogFile = "CombinedSystemMaintenanceLog_$hostname_$date"
$logFile = "$baseLogFile.txt"
$counter = 1
while (Test-Path $logFile) {
    $logFile = "${baseLogFile}_$counter.txt"
    $counter++
}
New-Item $logFile -ItemType File -Force | Out-Null
"Script Version: $scriptVersion" | Out-File -FilePath $logFile -Encoding UTF8
Write-Log "Script Version: $scriptVersion"

# Optional repair source for DISM /restorehealth - Can be set to a local WIM file if online repair is not possible.
$repairSource = $null  # Example: "WIM:D:\sources\install.wim:1"

# Function to prompt user for Yes/No input - Handles user confirmation with default option.
function Confirm-Action {
    param (
        [string]$Message,
        [string]$Default = "Y"
    )
    $validChoices = @("Y", "N")
    $choice = Read-Host "$Message (Y/N, default: $Default)"
    $choice = $choice.Trim().ToUpper()
    if (-not $choice) {
        $choice = $Default
    }
    if ($choice -notin $validChoices) {
        Write-Host "Invalid input. Using default: $Default" -ForegroundColor Yellow
        return $Default -eq "Y"
    }
    return $choice -eq "Y"
}

# Function to check internet connectivity - Tests connection to Microsoft for DISM online repair.
function Test-InternetConnection {
    try {
        Test-Connection -ComputerName "www.microsoft.com" -Count 1 -Quiet -ErrorAction Stop
        return $true
    } catch {
        return $false
    }
}

# OS Compatibility Check - Ensures the script runs only on supported OS versions.
$osInfo = Get-ComputerInfo
$isServer = $osInfo.OsName -match "Server"
$isWin10OrLater = [System.Version]$osInfo.OsVersion -ge [System.Version]"10.0"
if (-not $isWin10OrLater) {
    Write-Log "Unsupported OS: $($osInfo.OsName). Script optimized for Windows 10/11 and Server 2019+."
    Write-Host "Unsupported OS. Exiting." -ForegroundColor Red
    exit
}
Write-Log "OS Detected: $($osInfo.OsName) - Server: $isServer"

# Initialize summary variables - Tracks errors, repairs, and other metrics across sections for final summary.
$osErrors = 0
$osRepairs = 0
$diskErrors = 0
$diskRepairs = 0
$corruptedShadows = 0
$shadowsDeleted = 0
$defragErrors = 0
$defragOptimizations = 0
$cleanupErrors = 0
$totalBytesFreed = 0
$smartIssues = 0
$driverIssues = 0
$failedUpdateCount = 0
$defenderErrors = 0
$threatCount = 0

# Initial System State Check (Pending Updates and Restarts) - Checks for pending updates and restarts to ensure clean state.
Write-Log "Starting Initial System State Check..."
$pendingUpdates = 0
$pendingUpdateDetails = @()
$pendingRestartSources = @()

# Check for pending Windows Updates - Uses PSWindowsUpdate module or falls back to Get-HotFix.
Write-Log "Checking for pending Windows Updates..."
try {
    if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) {
        Write-Log "Installing PSWindowsUpdate module..."
        Install-Module -Name PSWindowsUpdate -Force -Scope CurrentUser -ErrorAction Stop
        Write-Log "PSWindowsUpdate module installed."
    }
    Import-Module PSWindowsUpdate -ErrorAction Stop
    $updates = Get-WUList -ErrorAction Stop
    $pendingUpdates = ($updates | Where-Object { $_.Status -eq "Pending" -or $_.IsMandatory }).Count
    $pendingUpdateDetails = $updates | Where-Object { $_.Status -eq "Pending" -or $_.IsMandatory } | Select-Object KB, Title
    if ($pendingUpdates -gt 0) {
        Write-Log "Found $pendingUpdates pending updates:"
        $pendingUpdateDetails | ForEach-Object { Write-Log "  KB: $($_.KB), Title: $($_.Title)" }
        Write-Host "`nPending Updates: $pendingUpdates found" -ForegroundColor Yellow
        $pendingUpdateDetails | ForEach-Object { Write-Host "  KB: $($_.KB), Title: $($_.Title)" }
    } else {
        Write-Log "No pending updates found."
        Write-Host "`nPending Updates: None found" -ForegroundColor Green
    }
} catch {
    Write-Log "PSWindowsUpdate unavailable: $_"
    Write-Host "`nPending Updates: PSWindowsUpdate unavailable, falling back to Get-HotFix" -ForegroundColor Yellow
    $recentUpdates = Get-HotFix | Where-Object { $_.InstalledOn -gt (Get-Date).AddDays(-30) }
    $pendingUpdates = $recentUpdates.Count
    $pendingUpdateDetails = $recentUpdates | Select-Object HotFixID, Description
    if ($pendingUpdates -gt 0) {
        Write-Log "Found $pendingUpdates recent updates (past 30 days):"
        $pendingUpdateDetails | ForEach-Object { Write-Log "  HotFixID: $($_.HotFixID), Description: $($_.Description)" }
        Write-Host "Pending Updates: $pendingUpdates recent updates found" -ForegroundColor Yellow
        $pendingUpdateDetails | ForEach-Object { Write-Host "  HotFixID: $($_.HotFixID), Description: $($_.Description)" }
    } else {
        Write-Log "No recent updates found via Get-HotFix."
        Write-Host "Pending Updates: None found via Get-HotFix" -ForegroundColor Green
    }
}

# Check for pending restarts - Inspects registry keys and SCCM for reboot requirements.
Write-Log "Checking for pending restarts..."
if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") {
    $pendingRestartSources += "Windows Update"
    Write-Log "Pending restart: Windows Update"
    Write-Host "`nPending Restart: Windows Update" -ForegroundColor Yellow
}
if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending") {
    $pendingRestartSources += "Component-Based Servicing"
    Write-Log "Pending restart: Component-Based Servicing"
    Write-Host "Pending Restart: Component-Based Servicing" -ForegroundColor Yellow
}
if (Test-Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\PendingFileRenameOperations") {
    $pendingRestartSources += "Pending File Rename Operations"
    Write-Log "Pending restart: Pending File Rename Operations"
    Write-Host "Pending Restart: Pending File Rename Operations" -ForegroundColor Yellow
}
try {
    $sccmReboot = Invoke-CimMethod -Namespace "root\ccm\ClientSDK" -Class "CCM_ClientUtilities" -Name "DetermineIfRebootPending" -ErrorAction Stop
    if ($sccmReboot.RebootPending) {
        $pendingRestartSources += "SCCM Client"
        Write-Log "Pending restart: SCCM Client"
        Write-Host "Pending Restart: SCCM Client" -ForegroundColor Yellow
    }
} catch {
    Write-Log "SCCM client check unavailable: $_"
}

# Prompt for restart if needed - Offers to restart if pending changes are detected.
if ($pendingUpdates -gt 0 -or $pendingRestartSources) {
    Write-Log "Pending updates ($pendingUpdates) or restarts ($($pendingRestartSources -join ', ')) detected."
    Write-Host "`nInitial System State Summary:" -ForegroundColor Green
    Write-Host "Pending Updates: $pendingUpdates"
    Write-Host "Pending Restarts: $($pendingRestartSources -join ', ')"
    if (Confirm-Action -Message "Pending updates or restarts detected. Restart now to apply changes?" -Default "Y") {
        Write-Log "Initiating system restart..."
        Write-Host "Initiating system restart..." -ForegroundColor Cyan
        Restart-Computer -Force
        exit
    } else {
        Write-Log "User declined restart. Proceeding with maintenance."
        Write-Host "`nWarning: Proceeding without restart. Results may be affected." -ForegroundColor Yellow
    }
} else {
    Write-Log "No pending updates or restarts detected."
    Write-Host "`nInitial System State Summary:" -ForegroundColor Green
    Write-Host "Pending Updates: None"
    Write-Host "Pending Restarts: None"
}

# Check for Sysinternals Suite - Downloads and installs if not present for tools like Contig.
$sysinternalsPath = "C:\SysinternalsSuite"
if (-not (Test-Path $sysinternalsPath)) {
    Write-Host "`nSysinternals Suite not found at $sysinternalsPath" -ForegroundColor Yellow
    if (Confirm-Action -Message "Download and extract Sysinternals Suite to $sysinternalsPath?" -Default "N") {
        Write-Log "Starting Sysinternals Suite download..."
        try {
            $zipUrl = "https://download.sysinternals.com/files/SysinternalsSuite.zip"
            $tempZip = [System.IO.Path]::GetTempFileName() + ".zip"
            Invoke-WebRequest -Uri $zipUrl -OutFile $tempZip
            Write-Log "Extracting to $sysinternalsPath..."
            New-Item -Path $sysinternalsPath -ItemType Directory -Force | Out-Null
            Expand-Archive -Path $tempZip -DestinationPath $sysinternalsPath -Force
            Remove-Item -Path $tempZip
            Write-Log "Adding $sysinternalsPath to PATH..."
            $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
            if ($currentPath -notlike "*$sysinternalsPath*") {
                [Environment]::SetEnvironmentVariable("Path", "$currentPath;$sysinternalsPath", "Machine")
            }
            Write-Log "Sysinternals Suite installed."
            Write-Host "`nResult: Sysinternals Suite installed" -ForegroundColor Green
        } catch {
            Write-Log "Error downloading Sysinternals Suite: $_"
            Write-Host "`nResult: Error - $_" -ForegroundColor Red
        }
    } else {
        Write-Log "Skipped Sysinternals Suite download."
        Write-Host "`nResult: Skipped Sysinternals Suite download" -ForegroundColor Green
    }
}

# Check if Contig is available - Used for MFT defragmentation in disk maintenance.
$contigAvailable = Get-Command "contig" -ErrorAction SilentlyContinue

# Step 1: Check TRIM status - Enables TRIM for SSD optimization if not already set.
if (Confirm-Action -Message "Check and enable TRIM for SSD optimization?" -Default "Y") {
    Write-Log "Starting TRIM check..."
    $trimStatus = fsutil behavior query DisableDeleteNotify
    if ($trimStatus -match "DisableDeleteNotify = 0") {
        Write-Log "Result: TRIM is enabled."
        Write-Host "`nTRIM Check Result: Enabled" -ForegroundColor Green
    } else {
        Write-Log "Command: fsutil behavior set DisableDeleteNotify 0"
        fsutil behavior set DisableDeleteNotify 0
        Write-Log "Result: TRIM enabled."
        Write-Host "`nTRIM Check Result: Disabled, now enabled" -ForegroundColor Green
    }
} else {
    Write-Log "Skipped TRIM check."
    Write-Host "`nTRIM Check Result: Skipped" -ForegroundColor Green
}

# Step 2: Get all NTFS drives and their types - Detects drives, media types for optimized handling.
$physicalDisks = Get-PhysicalDisk | Select-Object DeviceId, MediaType, FriendlyName, UniqueId
$ntfsDrives = Get-Volume | Where-Object { $_.FileSystem -eq "NTFS" -and $_.DriveLetter } | ForEach-Object {
    $volume = $_
    $partition = Get-Partition | Where-Object { $_.DriveLetter -eq $volume.DriveLetter }
    $disk = if ($partition) { Get-Disk -Number ($partition.DiskNumber) } else { $null }
    $mediaType = if ($disk) {
        $physicalDisk = $physicalDisks | Where-Object { $_.UniqueId -eq $disk.UniqueId }
        if ($physicalDisk.MediaType) {
            $physicalDisk.MediaType
        } elseif ($physicalDisk.FriendlyName -match "SSD|NVMe") {
            "SSD"
        } else {
            "HDD"
        }
    } else {
        "HDD"
    }
    [PSCustomObject]@{
        DriveLetter = $volume.DriveLetter
        MediaType = $mediaType
        FriendlyName = if ($physicalDisk) { $physicalDisk.FriendlyName } else { "Unknown" }
    }
}
if (-not $ntfsDrives) {
    Write-Log "No NTFS drives found. Exiting."
    Write-Host "`nDrive Detection Summary: No NTFS drives found. Exiting." -ForegroundColor Green
    exit
}
$ssdDrives = $ntfsDrives | Where-Object { $_.MediaType -eq "SSD" } | Select-Object -ExpandProperty DriveLetter
$nonSsdDrives = $ntfsDrives | Where-Object { $_.MediaType -ne "SSD" } | Select-Object -ExpandProperty DriveLetter
Write-Log "Found NTFS drives: $($ntfsDrives.DriveLetter -join ', ')"
Write-Log "SSD drives: $($ssdDrives -join ', ')"
Write-Log "Non-SSD drives: $($nonSsdDrives -join ', ')"
foreach ($drive in $ntfsDrives) {
    Write-Log "Drive $($drive.DriveLetter): MediaType=$($drive.MediaType), FriendlyName=$($drive.FriendlyName)"
}
Write-Host "`nDrive Detection Summary:" -ForegroundColor Green
Write-Host "NTFS Drives: $($ntfsDrives.DriveLetter -join ', ')"
Write-Host "SSD Drives: $($ssdDrives -join ', ')"
Write-Host "Non-SSD Drives: $($nonSsdDrives -join ', ')"

# OS Maintenance Section - Performs DISM and SFC scans/repairs with progress and skips.
if (Confirm-Action -Message "Proceed with OS Maintenance (DISM and SFC)?" -Default "Y") {
    $osCommands = @(
        @{Command = "/online /cleanup-image /checkhealth"; Description = "CheckHealth - Check for component store corruption (dism /online /cleanup-image /checkhealth)"; Executable = "dism"},
        @{Command = "/online /cleanup-image /scanhealth"; Description = "ScanHealth - Perform a deeper scan for corruption (dism /online /cleanup-image /scanhealth)"; Executable = "dism"},
        @{Command = if ($repairSource) { "/online /cleanup-image /restorehealth /source:$repairSource" } else { "/online /cleanup-image /restorehealth" }; Description = "RestoreHealth - Repair the component store (dism /online /cleanup-image /restorehealth$(if ($repairSource) { " /source:$repairSource" }))"; Executable = "dism"},
        @{Command = "/online /cleanup-image /AnalyzeComponentStore"; Description = "AnalyzeComponentStore - Analyze component store size (dism /online /cleanup-image /AnalyzeComponentStore)"; Executable = "dism"},
        @{Command = "/online /cleanup-image /StartComponentCleanup"; Description = "StartComponentCleanup - Clean up superseded components (dism /online /cleanup-image /StartComponentCleanup)"; Executable = "dism"},
        @{Command = "/scannow"; Description = "SFC Scan - Scan and repair system files (sfc /scannow)"; Executable = "sfc"}
    )

    # Pre-check for internet connectivity if no repair source - Ensures online repair is possible or prompts for local source.
    if (-not $repairSource) {
        Write-Log "Checking internet connectivity for DISM /restorehealth..."
        if (-not (Test-InternetConnection)) {
            Write-Log "No internet connection. DISM /restorehealth may fail."
            Write-Host "`nWarning: No internet connection. DISM /restorehealth may fail." -ForegroundColor Yellow
            if (Confirm-Action -Message "Specify a local repair source (e.g., WIM:D:\sources\install.wim:1)? (default: N)" -Default "N") {
                $repairSource = Read-Host "Enter repair source (e.g., WIM:D:\sources\install.wim:1)"
                Write-Log "Repair source specified: $repairSource"
                $osCommands[2].Command = "/online /cleanup-image /restorehealth /source:$repairSource"
                $osCommands[2].Description = "RestoreHealth - Repair the component store (dism /online /cleanup-image /restorehealth /source:$repairSource)"
            } else {
                Write-Log "No repair source provided. Using online DISM /restorehealth."
                Write-Host "Proceeding with online DISM /restorehealth." -ForegroundColor Yellow
            }
        } else {
            Write-Log "Internet connection detected."
            Write-Host "`nInternet connection detected for DISM /restorehealth." -ForegroundColor Green
        }
    }

    # Check if SFC has been run - Prompts to run SFC first if no recent scan detected.
    $sfcRun = (Get-WinEvent -FilterHashtable @{LogName='System'; ID=1001; ProviderName='Microsoft-Windows-WindowsUpdateClient'} -MaxEvents 10 -ErrorAction SilentlyContinue | Where-Object { $_.Message -match "sfc /scannow" }).Count
    if ($sfcRun -eq 0) {
        Write-Log "No recent SFC scan detected. Recommending SFC before DISM /restorehealth."
        if (Confirm-Action -Message "No recent SFC scan detected. Run SFC first?" -Default "Y") {
            $osCommands = @($osCommands[5]) + $osCommands[0..4]
        }
    } else {
        Write-Log "Recent SFC scan detected. Proceeding with DISM commands."
    }

    # Execute OS maintenance commands - Runs each command with logging and error handling.
    foreach ($cmd in $osCommands) {
        if (Confirm-Action -Message "Run $($cmd.Description)?" -Default "Y") {
            Write-Log "Starting: $($cmd.Description)"
            Write-Host "`nRunning: $($cmd.Description)" -ForegroundColor Cyan
            Write-Log "Command: $($cmd.Executable) $($cmd.Command)"
            try {
                $output = & $cmd.Executable $cmd.Command.Split(' ') 2>&1
                if ($output -match "error|failed|corrupt") {
                    Write-Log "Result: Error detected: $output"
                    Write-Host "`nResult: Error - $output" -ForegroundColor Red
                    $osErrors++
                } else {
                    Write-Log "Result: Completed successfully."
                    Write-Host "`nResult: Completed successfully" -ForegroundColor Green
                    $osRepairs++
                }
            } catch {
                Write-Log "Result: Error running command: $_"
                Write-Host "`nResult: Error - $_" -ForegroundColor Red
                $osErrors++
            }
        } else {
            Write-Log "Result: Skipped $($cmd.Description)"
            Write-Host "`nResult: Skipped" -ForegroundColor Yellow
        }
    }

    Write-Log "OS Maintenance Summary: Errors=$osErrors, Repairs=$osRepairs"
    Write-Host "`nOS Maintenance Summary: Errors=$osErrors, Repairs=$osRepairs" -ForegroundColor Green
} else {
    Write-Log "OS Maintenance Summary: Skipped"
    Write-Host "`nOS Maintenance Summary: Skipped" -ForegroundColor Green
}

# Disk Maintenance Section - Performs CHKDSK, fsutil repairquery, and Contig for MFT if available.
$contigOutputs = @{}
if (Confirm-Action -Message "Proceed with Disk Maintenance (CHKDSK, fsutil, Contig)?" -Default "Y") {
    foreach ($drive in $ntfsDrives) {
        # CHKDSK scan - Checks for disk errors without fixing.
        Write-Log "Starting: CHKDSK Scan for $($drive.DriveLetter): (chkdsk $($drive.DriveLetter): /scan /perf)"
        Write-Host "`nRunning: CHKDSK Scan for $($drive.DriveLetter): (chkdsk $($drive.DriveLetter): /scan /perf)" -ForegroundColor Cyan
        Write-Log "Command: chkdsk $($drive.DriveLetter): /scan /perf"
        try {
            $chkdskOutput = chkdsk "$($drive.DriveLetter):" /scan /perf 2>&1
            if ($chkdskOutput -match "found \d+ bad|corruption") {
                Write-Log "Result: Corruption detected on $($drive.DriveLetter):"
                Write-Host "`nResult: Corruption detected" -ForegroundColor Yellow
                $diskErrors++
                if (Confirm-Action -Message "Corruption detected on $($drive.DriveLetter):. Schedule repair on reboot?" -Default "Y") {
                    Write-Log "Command: chkdsk $($drive.DriveLetter): /f /r"
                    chkdsk "$($drive.DriveLetter):" /f /r
                    Write-Log "Result: Repair scheduled on reboot."
                    Write-Host "`nResult: Repair scheduled on reboot" -ForegroundColor Green
                    $diskRepairs++
                } else {
                    Write-Log "Result: User declined repair."
                    Write-Host "`nResult: Declined repair" -ForegroundColor Yellow
                }
            } else {
                Write-Log "Result: No corruption detected."
                Write-Host "`nResult: No corruption detected" -ForegroundColor Green
            }
        } catch {
            Write-Log "Result: Error running CHKDSK: $_"
            Write-Host "`nResult: Error - $_" -ForegroundColor Red
            $diskErrors++
        }

        # fsutil repairquery - Checks for self-healing status and corruption.
        Write-Log "Starting: fsutil repairquery for $($drive.DriveLetter): (fsutil repair query $($drive.DriveLetter):)"
        Write-Host "`nRunning: fsutil repairquery for $($drive.DriveLetter): (fsutil repair query $($drive.DriveLetter):)" -ForegroundColor Cyan
        Write-Log "Command: fsutil repair query $($drive.DriveLetter):"
        try {
            $fsutilOutput = fsutil repair query "$($drive.DriveLetter):" 2>&1
            if ($fsutilOutput -match "0x0") {
                Write-Log "Result: No corruption detected."
                Write-Host "`nResult: No corruption detected" -ForegroundColor Green
            } else {
                Write-Log "Result: Corruption detected: $fsutilOutput"
                Write-Host "`nResult: Corruption detected - $fsutilOutput" -ForegroundColor Yellow
                $diskErrors++
            }
        } catch {
            Write-Log "Result: Error running fsutil: $_"
            Write-Host "`nResult: Error - $_" -ForegroundColor Red
            $diskErrors++
        }

        # Contig for MFT defragmentation if available
        if ($contigAvailable) {
            Write-Log "Starting: Contig for MFT defragmentation on $($drive.DriveLetter): (contig.exe $($drive.DriveLetter):\`$mft -v)"
            Write-Host "`nRunning: Contig for MFT defragmentation on $($drive.DriveLetter): (contig.exe $($drive.DriveLetter):\`$mft -v)" -ForegroundColor Cyan
            Write-Log "Command: contig.exe $($drive.DriveLetter):\`$mft -v"
            try {
                $contigOutput = & contig.exe "$($drive.DriveLetter):\`$mft" -v 2>&1
                $contigOutputs["$($drive.DriveLetter):\`$mft"] = $contigOutput
                if ($contigOutput -match "error|failed") {
                    Write-Log "Result: Error in MFT defragmentation: $contigOutput"
                    Write-Host "`nResult: Error - $contigOutput" -ForegroundColor Red
                    $diskErrors++
                } else {
                    Write-Log "Result: MFT defragmented successfully."
                    Write-Host "`nResult: MFT defragmented successfully" -ForegroundColor Green
                    $diskRepairs++
                }
            } catch {
                Write-Log "Result: Error running Contig: $_"
                Write-Host "`nResult: Error - $_" -ForegroundColor Red
                $diskErrors++
            }
        } else {
            Write-Log "Result: Contig not available, skipping MFT defragmentation."
            Write-Host "`nResult: Contig not available, skipping" -ForegroundColor Yellow
        }
    }

    Write-Log "Disk Maintenance Summary: Errors=$diskErrors, Repairs=$diskRepairs"
    Write-Host "`nDisk Maintenance Summary: Errors=$diskErrors, Repairs=$diskRepairs" -ForegroundColor Green
} else {
    Write-Log "Disk Maintenance Summary: Skipped"
    Write-Host "`nDisk Maintenance Summary: Skipped" -ForegroundColor Green
}

# Shadow Copy Maintenance Section - Checks and deletes corrupted shadow copies.
if (Confirm-Action -Message "Proceed with Shadow Copy Maintenance?" -Default "Y") {
    Write-Log "Starting Shadow Copy Maintenance..."
    $shadowCopies = vssadmin list shadows /all 2>&1
    $corruptedShadows = $shadowCopies | Select-String "Error: 0x" | Measure-Object | Select-Object -ExpandProperty Count
    if ($corruptedShadows -gt 0) {
        Write-Log "Corrupted shadow copies detected: $corruptedShadows"
        Write-Host "`nCorrupted shadow copies: $corruptedShadows" -ForegroundColor Yellow
        if (Confirm-Action -Message "Delete corrupted shadow copies?" -Default "Y") {
            Write-Log "Command: vssadmin delete shadows /all /quiet"
            try {
                vssadmin delete shadows /all /quiet 2>&1
                Write-Log "Result: Corrupted shadow copies deleted."
                Write-Host "`nResult: Deleted" -ForegroundColor Green
                $shadowsDeleted = $corruptedShadows
            } catch {
                Write-Log "Result: Error deleting shadows: $_"
                Write-Host "`nResult: Error - $_" -ForegroundColor Red
            }
        } else {
            Write-Log "Result: Skipped deletion."
            Write-Host "`nResult: Skipped" -ForegroundColor Yellow
        }
    } else {
        Write-Log "Result: No corrupted shadow copies found."
        Write-Host "`nResult: No corrupted shadows" -ForegroundColor Green
    }
} else {
    Write-Log "Shadow Copy Maintenance Summary: Skipped"
    Write-Host "`nShadow Copy Maintenance Summary: Skipped" -ForegroundColor Green
}

# Drive Optimization Section - Performs TRIM for SSDs and defrag for HDDs.
if (Confirm-Action -Message "Proceed with Drive Optimization (defrag)?" -Default "Y") {
    Write-Log "Starting Drive Optimization..."
    if ($ssdDrives) {
        Write-Log "SSD drives detected: $($ssdDrives -join ', ')"
        foreach ($ssd in $ssdDrives) {
            Write-Log "Starting: SSD Optimization for $($ssd): (defrag $($ssd): /O /V)"
            Write-Host "`nRunning: SSD Optimization for $($ssd): (defrag $($ssd): /O /V)" -ForegroundColor Cyan
            Write-Log "Command: defrag $($ssd): /O /V"
            try {
                $defragOutput = defrag "$($ssd):" /O /V 2>&1
                if ($defragOutput -match "error|failed") {
                    Write-Log "Result: Error optimizing SSD: $defragOutput"
                    Write-Host "`nResult: Error - $defragOutput" -ForegroundColor Red
                    $defragErrors++
                } else {
                    Write-Log "Result: TRIM completed for $($ssd)."
                    Write-Host "`nResult: TRIM completed" -ForegroundColor Green
                    $defragOptimizations++
                }
            } catch {
                Write-Log "Result: Error running defrag: $_"
                Write-Host "`nResult: Error - $_" -ForegroundColor Red
                $defragErrors++
            }
        }
    }
    if ($nonSsdDrives) {
        Write-Log "Non-SSD drives detected: $($nonSsdDrives -join ', ')"
        if (Confirm-Action -Message "Run defrag on non-SSD drives? (May take time)" -Default "N") {
            foreach ($hdd in $nonSsdDrives) {
                Write-Log "Starting: HDD Defragmentation for $($hdd): (defrag $($hdd): /U /V)"
                Write-Host "`nRunning: HDD Defragmentation for $($hdd): (defrag $($hdd): /U /V)" -ForegroundColor Cyan
                Write-Log "Command: defrag $($hdd): /U /V"
                try {
                    $defragOutput = defrag "$($hdd):" /U /V 2>&1
                    if ($defragOutput -match "error|failed") {
                        Write-Log "Result: Error defragmenting HDD: $defragOutput"
                        Write-Host "`nResult: Error - $defragOutput" -ForegroundColor Red
                        $defragErrors++
                    } else {
                        Write-Log "Result: Defragmentation completed for $($hdd)."
                        Write-Host "`nResult: Defragmentation completed" -ForegroundColor Green
                        $defragOptimizations++
                    }
                } catch {
                    Write-Log "Result: Error running defrag: $_"
                    Write-Host "`nResult: Error - $_" -ForegroundColor Red
                    $defragErrors++
                }
            }
        } else {
            Write-Log "Result: Skipped non-SSD defragmentation."
            Write-Host "`nResult: Skipped non-SSD defragmentation" -ForegroundColor Yellow
        }
    }

    Write-Log "Drive Optimization Summary: Errors=$defragErrors, Optimizations=$defragOptimizations"
    Write-Host "`nDrive Optimization Summary: Errors=$defragErrors, Optimizations=$defragOptimizations" -ForegroundColor Green
} else {
    Write-Log "Drive Optimization Summary: Skipped"
    Write-Host "`nDrive Optimization Summary: Skipped" -ForegroundColor Green
}

# Temp File Cleanup Section - Cleans temporary folders and SoftwareDistribution.
if (Confirm-Action -Message "Proceed with Temp File Cleanup?" -Default "Y") {
    Write-Log "Starting Temp File Cleanup..."
    $tempFolders = @(
        "$env:windir\Temp",
        "$env:temp",
        "$env:windir\SoftwareDistribution\Download"
    )
    foreach ($folder in $tempFolders) {
        Write-Log "Starting: Cleaning $folder"
        Write-Host "`nCleaning: $folder" -ForegroundColor Cyan
        try {
            $bytesFreed = (Get-ChildItem $folder -Recurse -Force | Measure-Object -Property Length -Sum).Sum / 1MB
            Remove-Item "$folder\*" -Recurse -Force -ErrorAction SilentlyContinue
            Write-Log "Result: Cleaned $folder, freed $($bytesFreed) MB."
            Write-Host "`nResult: Freed $($bytesFreed) MB" -ForegroundColor Green
            $totalBytesFreed += $bytesFreed
        } catch {
            Write-Log "Result: Error cleaning ${folder}: $_"
            Write-Host "`nResult: Error - $_" -ForegroundColor Red
            $cleanupErrors++
        }
    }

    Write-Log "Temp File Cleanup Summary: Errors=$cleanupErrors, Bytes Freed=$totalBytesFreed MB"
    Write-Host "`nTemp File Cleanup Summary: Errors=$cleanupErrors, Bytes Freed=$totalBytesFreed MB" -ForegroundColor Green
} else {
    Write-Log "Temp File Cleanup Summary: Skipped"
    Write-Host "`nTemp File Cleanup Summary: Skipped" -ForegroundColor Green
}

# Hardware and Driver Checks Section - Checks SMART status and driver issues.
if (Confirm-Action -Message "Proceed with Hardware and Driver Checks?" -Default "Y") {
    Write-Log "Starting Hardware and Driver Checks..."
    # SMART status check - Requires smartctl or similar; fallback to wmic.
    try {
        $smartStatus = Get-WmiObject -Namespace root\wmi -Class MSStorageDriver_FailurePredictStatus | Select-Object -ExpandProperty PredictFailure
        $smartIssues = ($smartStatus | Where-Object { $_ -eq $true }).Count
        Write-Log "SMART Check: Issues=$smartIssues"
        Write-Host "`nSMART Check: Issues=$smartIssues" -ForegroundColor Green
    } catch {
        Write-Log "SMART Check unavailable: $_"
        Write-Host "`nSMART Check: Unavailable" -ForegroundColor Yellow
    }

    # Driver issues check - Scans for problematic drivers.
    $driverIssues = (Get-WinEvent -FilterHashtable @{LogName='System'; ID=219} -MaxEvents 10 -ErrorAction SilentlyContinue).Count
    Write-Log "Driver Issues (recent events): $driverIssues"
    Write-Host "Driver Issues: $driverIssues" -ForegroundColor Green

    Write-Log "Hardware and Driver Checks Summary: SMART Issues=$smartIssues, Driver Issues=$driverIssues"
    Write-Host "`nHardware and Driver Checks Summary: SMART Issues=$smartIssues, Driver Issues=$driverIssues" -ForegroundColor Green
} else {
    Write-Log "Hardware and Driver Checks Summary: Skipped"
    Write-Host "`nHardware and Driver Checks Summary: Skipped" -ForegroundColor Green
}

# Memory and Update Checks Section - Runs memory diagnostic and checks failed updates.
if (Confirm-Action -Message "Proceed with Memory and Update Checks?" -Default "Y") {
    Write-Log "Starting Memory and Update Checks..."
    # Memory Diagnostic - Schedules on reboot.
    if (Confirm-Action -Message "Schedule Memory Diagnostic on reboot?" -Default "N") {
        Write-Log "Command: mdsched.exe /run"
        mdsched.exe
        Write-Log "Result: Memory Diagnostic scheduled."
        Write-Host "`nResult: Scheduled on reboot" -ForegroundColor Green
    } else {
        Write-Log "Result: Skipped Memory Diagnostic."
        Write-Host "`nResult: Skipped" -ForegroundColor Yellow
    }

    # Failed Updates Check - Counts failed updates from event logs.
    $failedUpdates = Get-WinEvent -FilterHashtable @{LogName='System'; ID=20,22,25,43} -MaxEvents 50 -ErrorAction SilentlyContinue
    $failedUpdateCount = $failedUpdates.Count
    Write-Log "Failed Updates (recent): $failedUpdateCount"
    Write-Host "Failed Updates: $failedUpdateCount" -ForegroundColor Green

    Write-Log "Memory and Update Checks Summary: Failed Updates=$failedUpdateCount"
    Write-Host "`nMemory and Update Checks Summary: Failed Updates=$failedUpdateCount" -ForegroundColor Green
} else {
    Write-Log "Memory and Update Checks Summary: Skipped"
    Write-Host "`nMemory and Update Checks Summary: Skipped" -ForegroundColor Green
}

# Malware Scan Section - Performs quick Defender scan, handles third-party AV.
if (Confirm-Action -Message "Proceed with Quick Malware Scan (Windows Defender)?" -Default "Y") {
    Write-Log "Starting Quick Malware Scan..."
    # Check for Windows Defender service and third-party antivirus.
    $defenderService = Get-Service -Name WinDefend -ErrorAction SilentlyContinue
    $thirdPartyAV = Get-CimInstance -Namespace "root/SecurityCenter2" -ClassName AntiVirusProduct -ErrorAction SilentlyContinue
    $defenderEnabled = $true
    $defenderRecommendations = @()

    if ($thirdPartyAV) {
        Write-Log "Result: Third-party antivirus detected: $($thirdPartyAV.displayName -join ', ')"
        Write-Host "`nThird-party antivirus detected: $($thirdPartyAV.displayName -join ', ')" -ForegroundColor Yellow
        $defenderEnabled = $false
        $defenderRecommendations += "Verify third-party antivirus status."
    }

    if ($defenderService) {
        if ($defenderService.Status -ne "Running") {
            Write-Log "Command: Start-Service -Name WinDefend"
            try {
                Start-Service -Name WinDefend -ErrorAction Stop
                Write-Log "Result: Windows Defender service started."
                Write-Host "`nDefender Service Result: Started" -ForegroundColor Green
            } catch {
                Write-Log "Result: Failed to start Windows Defender: $_"
                Write-Host "`nDefender Service Result: Error - $_" -ForegroundColor Red
                $defenderEnabled = $false
                $defenderRecommendations += "Check Windows Defender in services.msc."
            }
        } else {
            Write-Log "Result: Windows Defender service is running."
            Write-Host "`nDefender Service Result: Running" -ForegroundColor Green
        }
    } else {
        Write-Log "Result: Windows Defender service not found."
        Write-Host "`nDefender Service Result: Not found" -ForegroundColor Red
        $defenderEnabled = $false
        $defenderRecommendations += "Reinstall Windows Defender."
    }

    # Run quick malware scan if Defender is enabled.
    if ($defenderEnabled) {
        Write-Log "Starting: Quick Malware Scan (Start-MpScan -ScanType QuickScan)"
        Write-Host "`nRunning: Quick Malware Scan (Start-MpScan -ScanType QuickScan)" -ForegroundColor Cyan
        Write-Log "Command: Start-MpScan -ScanType QuickScan"
        try {
            Start-MpScan -ScanType QuickScan -ErrorAction Stop
            $defenderEvents = Get-WinEvent -FilterHashtable @{
                LogName = 'Microsoft-Windows-Windows Defender/Operational'
                ID = @(1000, 1001)
                StartTime = (Get-Date).AddHours(-1)
            } -ErrorAction SilentlyContinue
            $threats = $defenderEvents | Where-Object { $_.Message -match "threat detected" }
            $threatCount = if ($threats) { $threats.Count } else { 0 }
            if ($threats) {
                Write-Log "Result: $threatCount threats detected."
                Write-Host "`nResult: $threatCount threats detected" -ForegroundColor Yellow
                $defenderRecommendations += "Run full scan (Start-MpScan -ScanType FullScan)."
            } else {
                Write-Log "Result: No threats found."
                Write-Host "`nResult: No threats found" -ForegroundColor Green
            }
        } catch {
            Write-Log "Result: Error running scan: $_"
            Write-Host "`nResult: Error - $_" -ForegroundColor Red
            $defenderRecommendations += "Update Defender definitions (MpCmdRun -SignatureUpdate)."
            $defenderErrors++
        }
    } else {
        Write-Log "Result: Skipped scan due to Defender being disabled."
        Write-Host "`nResult: Skipped due to Defender disabled" -ForegroundColor Yellow
        $defenderRecommendations += "Enable Windows Defender via gpedit.msc."
    }

    Write-Log "Malware Scan Summary: Defender Enabled=$($defenderEnabled), Threats Detected=$(if ($defenderEnabled) { $threatCount } else { 'N/A' })"
    Write-Host "`nMalware Scan Summary:" -ForegroundColor Green
    Write-Host "Defender Enabled: $(if ($defenderEnabled) { 'Yes' } else { 'No' })"
    Write-Host "Threats Detected: $(if ($defenderEnabled) { $threatCount } else { 'N/A' })"
    if ($defenderRecommendations) {
        Write-Log "Recommendations: $($defenderRecommendations -join '; ')"
        Write-Host "Recommendations:" -ForegroundColor Yellow
        $defenderRecommendations | ForEach-Object { Write-Host "- $_" }
    }
} else {
    Write-Log "Malware Scan Summary: Skipped"
    Write-Host "`nMalware Scan Summary: Skipped" -ForegroundColor Green
}

# Verify VSS service - Ensures Volume Shadow Copy service is running for shadow copy operations.
if (Confirm-Action -Message "Proceed with VSS Service Check?" -Default "Y") {
    Write-Log "Starting VSS Service Check..."
    Write-Log "Command: Get-Service -Name VSS"
    $vssStatus = Get-Service -Name VSS -ErrorAction SilentlyContinue
    if ($vssStatus -and $vssStatus.Status -eq "Running") {
        Write-Log "Result: VSS service is running."
        Write-Host "`nVSS Service Result: Running" -ForegroundColor Green
    } else {
        Write-Log "Command: Start-Service -Name VSS"
        try {
            Start-Service -Name VSS -ErrorAction Stop
            Write-Log "Result: VSS service started."
            Write-Host "`nVSS Service Result: Started" -ForegroundColor Green
        } catch {
            Write-Log "Result: Failed to start VSS service: $_"
            Write-Host "`nVSS Service Result: Error - $_" -ForegroundColor Red
        }
    }
} else {
    Write-Log "VSS Service Check Summary: Skipped"
    Write-Host "`nVSS Service Check Summary: Skipped" -ForegroundColor Green
}

# Log and Event Log Analysis Section - Analyzes logs and events for errors and repairs.
if (Confirm-Action -Message "Proceed with Log Analysis?" -Default "Y") {
    Write-Log "Starting Log Analysis..."
    # Define paths for DISM and CBS logs.
    $dismLogPath = "$env:windir\Logs\DISM\dism.log"
    $cbsLogPath = "$env:windir\Logs\CBS\cbs.log"
    
    # Initialize variables for tracking errors and repairs in logs.
    $dismErrors = 0
    $dismRepairs = 0
    $cbsErrors = 0
    $cbsRepairs = 0
    $chkdskErrors = 0
    $chkdskRepairs = 0
    $contigErrorsPerDrive = @{}
    $contigFragmentsPerDrive = @{}
    $fsutilCorruptedDrives = 0
    $vssErrors = 0
    $hardwareErrors = 0
    $driverErrors = 0

    # Define patterns for log analysis.
    $errorPattern = "error|failed|failure|corrupt|component store corruption|CBS operation failed"
    $repairPattern = "repaired|restored|fixed|successfully repaired"
    $chkdskErrorPattern = "found \d+ bad|corruption|error"
    $chkdskRepairPattern = "repaired|fixed|corrected|cleaned"
    $contigErrorPattern = "error|failed|cannot open"
    $contigFragmentPattern = "is in (\d+) fragments"
    $fsutilCorruptionPattern = "0x[1-9A-F]"
    $shadowCorruptionPattern = "0x[1-9A-F]"
    $defragErrorPattern = "error|failed"
    $defragOptPattern = "optimized|trimmed|defragmented"
    $cleanupErrorPattern = "Error cleaning.*Temp|SoftwareDistribution"
    $defenderErrorPattern = "Error running Quick Malware Scan"
    $serverErrorPattern = "WSUS|Server-specific error"  # Added for server-specific issues.

    # Analyze DISM log for errors and repairs.
    if (Test-Path $dismLogPath) {
        $dismErrors = (Select-String -Path $dismLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $dismRepairs = (Select-String -Path $dismLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
        Write-Log "DISM.log Analysis: Errors=$dismErrors, Repairs=$dismRepairs"
        Write-Host "`nDISM.log Analysis: Errors=$dismErrors, Repairs=$dismRepairs" -ForegroundColor Green
    } else {
        Write-Log "DISM.log not found at $dismLogPath"
        Write-Host "`nDISM.log not found at $dismLogPath" -ForegroundColor Yellow
    }
    
    # Analyze CBS log for errors and repairs.
    if (Test-Path $cbsLogPath) {
        $cbsErrors = (Select-String -Path $cbsLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $cbsRepairs = (Select-String -Path $cbsLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
        Write-Log "CBS.log Analysis: Errors=$cbsErrors, Repairs=$cbsRepairs"
        Write-Host "CBS.log Analysis: Errors=$cbsErrors, Repairs=$cbsRepairs" -ForegroundColor Green
    } else {
        Write-Log "CBS.log not found at $cbsLogPath"
        Write-Host "CBS.log not found at $cbsLogPath" -ForegroundColor Yellow
    }
    
    # Analyze system and application event logs for relevant errors.
    $eventIds = @(7,11,50,55,98,137,140,153,219,41,7023,2004,1001,12289,12290)
    $systemEvents = Get-WinEvent -FilterHashtable @{LogName='System'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $appEvents = Get-WinEvent -FilterHashtable @{LogName='Application'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $allEvents = $systemEvents + $appEvents

    $diskErrors = $allEvents | Where-Object { $_.Id -in @(7,11,50,55,98,137,140,153) } | Measure-Object | Select-Object -ExpandProperty Count
    $driverErrors = $allEvents | Where-Object { $_.Id -in @(219,7023) } | Measure-Object | Select-Object -ExpandProperty Count
    $hardwareErrors = $allEvents | Where-Object { $_.Id -in @(41,2004,1001) } | Measure-Object | Select-Object -ExpandProperty Count
    $vssErrors = $allEvents | Where-Object { $_.Id -in @(12289,12290) } | Measure-Object | Select-Object -ExpandProperty Count
    
    # Analyze Contig output for errors and fragmentation.
    foreach ($drivePath in $contigOutputs.Keys) {
        $driveType = ($ntfsDrives | Where-Object { $_.DriveLetter -eq $drivePath[0] }).MediaType
        $output = $contigOutputs[$drivePath]
        $contigErrorsPerDrive[$drivePath] = ($output | Select-String -Pattern $contigErrorPattern -CaseSensitive:$false | Measure-Object).Count
        $fragmentMatch = $output | Select-String -Pattern $contigFragmentPattern -CaseSensitive:$false
        $contigFragmentsPerDrive[$drivePath] = if ($fragmentMatch) { [int]$fragmentMatch.Matches.Groups[1].Value } else { 0 }
        Write-Log "Contig Analysis for $drivePath ($driveType): Errors=$($contigErrorsPerDrive[$drivePath]), Fragments=$($contigFragmentsPerDrive[$drivePath])"
        Write-Host "Contig Analysis for $drivePath ($driveType): Errors=$($contigErrorsPerDrive[$drivePath]), Fragments=$($contigFragmentsPerDrive[$drivePath])" -ForegroundColor Green
    }
    
    # Analyze script log for additional metrics.
    $fsutilCorruptedDrives = (Select-String -Path $logFile -Pattern $fsutilCorruptionPattern | Measure-Object).Count
    $shadowCorrupted = (Select-String -Path $logFile -Pattern $shadowCorruptionPattern | Measure-Object).Count
    $defragErrors = (Select-String -Path $logFile -Pattern $defragErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $defragOptimizations = (Select-String -Path $logFile -Pattern $defragOptPattern -CaseSensitive:$false | Measure-Object).Count
    $cleanupErrors = (Select-String -Path $logFile -Pattern $cleanupErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $defenderErrors = (Select-String -Path $logFile -Pattern $defenderErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $chkdskErrors = (Select-String -Path $logFile -Pattern $chkdskErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $chkdskRepairs = (Select-String -Path $logFile -Pattern $chkdskRepairPattern -CaseSensitive:$false | Measure-Object).Count
    $serverErrors = if ($isServer) { (Select-String -Path $logFile -Pattern $serverErrorPattern -CaseSensitive:$false | Measure-Object).Count } else { 0 }

    Write-Log "CHKDSK Analysis: Errors=$chkdskErrors, Repairs=$chkdskRepairs"
    Write-Host "CHKDSK Analysis: Errors=$chkdskErrors, Repairs=$chkdskRepairs" -ForegroundColor Green
    Write-Log "fsutil Analysis: Corrupted Drives=$fsutilCorruptedDrives"
    Write-Host "fsutil Analysis: Corrupted Drives=$fsutilCorruptedDrives" -ForegroundColor Green
    Write-Log "Shadow Copy Analysis: Corrupted Shadows=$shadowCorrupted"
    Write-Host "Shadow Copy Analysis: Corrupted Shadows=$shadowCorrupted" -ForegroundColor Green
    Write-Log "Defrag Analysis: Errors=$defragErrors, Optimizations=$defragOptimizations"
    Write-Host "Defrag Analysis: Errors=$defragErrors, Optimizations=$defragOptimizations" -ForegroundColor Green
    Write-Log "Cleanup Analysis: Errors=$cleanupErrors"
    Write-Host "Cleanup Analysis: Errors=$cleanupErrors" -ForegroundColor Green
    Write-Log "Defender Analysis: Errors=$defenderErrors"
    Write-Host "Defender Analysis: Errors=$defenderErrors" -ForegroundColor Green
    Write-Log "Event Log Analysis: Disk Errors=$diskErrors, Driver Errors=$driverErrors, Hardware Errors=$hardwareErrors, VSS Errors=$vssErrors"
    Write-Host "Event Log Analysis: Disk Errors=$diskErrors, Driver Errors=$driverErrors, Hardware Errors=$hardwareErrors, VSS Errors=$vssErrors" -ForegroundColor Green
    if ($isServer) {
        Write-Log "Server-Specific Analysis: Errors=$serverErrors"
        Write-Host "Server-Specific Analysis: Errors=$serverErrors" -ForegroundColor Green
    }

    # Generate recommendations based on analysis results.
    $recommendations = @()
    if ($dismErrors + $cbsErrors + $chkdskErrors + $diskErrors + $defragErrors + $cleanupErrors + $defenderErrors + $serverErrors -gt 0) {
        $recommendations += "Review detailed logs for errors."
        if ($isServer) { $recommendations += "Check WSUS configuration for server updates." }
    }
    if ($recommendations) {
        Write-Log "Recommendations: $($recommendations -join '; ')"
        Write-Host "Recommendations:" -ForegroundColor Yellow
        $recommendations | ForEach-Object { Write-Host "- $_" }
    }

    Write-Log "Log Analysis Summary: Total Errors Detected=$($dismErrors + $cbsErrors + $chkdskErrors + $diskErrors + $defragErrors + $cleanupErrors + $defenderErrors + $serverErrors)"
    Write-Host "`nLog Analysis Summary: Total Errors Detected=$($dismErrors + $cbsErrors + $chkdskErrors + $diskErrors + $defragErrors + $cleanupErrors + $defenderErrors + $serverErrors)" -ForegroundColor Green
} else {
    Write-Log "Log Analysis Summary: Skipped"
    Write-Host "`nLog Analysis Summary: Skipped" -ForegroundColor Green
}

# Final Summary Section - Aggregates all metrics and provides overall recommendations.
Write-Log "Starting Final Summary..."
Write-Host "`nFinal Summary:" -ForegroundColor Cyan
Write-Log "Script Version: $scriptVersion"
Write-Host "Script Version: $scriptVersion"
Write-Log "OS Errors: $osErrors, Repairs: $osRepairs"
Write-Host "OS Errors: $osErrors, Repairs: $osRepairs"
Write-Log "Disk Errors: $diskErrors, Repairs: $diskRepairs"
Write-Host "Disk Errors: $diskErrors, Repairs: $diskRepairs"
Write-Log "Corrupted Shadows: $corruptedShadows, Deleted: $shadowsDeleted"
Write-Host "Corrupted Shadows: $corruptedShadows, Deleted: $shadowsDeleted"
Write-Log "Defrag Errors: $defragErrors, Optimizations: $defragOptimizations"
Write-Host "Defrag Errors: $defragErrors, Optimizations: $defragOptimizations"
Write-Log "Cleanup Errors: $cleanupErrors, Bytes Freed: $totalBytesFreed MB"
Write-Host "Cleanup Errors: $cleanupErrors, Bytes Freed: $totalBytesFreed MB"
Write-Log "SMART Issues: $smartIssues, Driver Issues: $driverIssues"
Write-Host "SMART Issues: $smartIssues, Driver Issues: $driverIssues"
Write-Log "Failed Updates: $failedUpdateCount"
Write-Host "Failed Updates: $failedUpdateCount"
Write-Log "Defender Errors: $defenderErrors, Threats: $threatCount"
Write-Host "Defender Errors: $defenderErrors, Threats: $threatCount"

$totalErrors = $osErrors + $diskErrors + $defragErrors + $cleanupErrors + $smartIssues + $driverIssues + $defenderErrors + $failedUpdateCount + $corruptedShadows
$totalRepairs = $osRepairs + $diskRepairs + $defragOptimizations + $shadowsDeleted
Write-Log "Overall: Total Errors=$totalErrors, Total Repairs/Optimizations=$totalRepairs"
Write-Host "Overall: Total Errors=$totalErrors, Total Repairs/Optimizations=$totalRepairs"

$finalRecommendations = @()
if ($totalErrors -gt 0) {
    $finalRecommendations += "Address remaining errors; consider full system scan or reboot."
}
if ($isServer) {
    $finalRecommendations += "Verify server-specific configurations (e.g., WSUS, roles)."
}
if ($finalRecommendations) {
    Write-Log "Final Recommendations: $($finalRecommendations -join '; ')"
    Write-Host "Final Recommendations:" -ForegroundColor Yellow
    $finalRecommendations | ForEach-Object { Write-Host "- $_" }
}

Write-Log "Script execution completed."
Write-Host "`nScript execution completed." -ForegroundColor Cyan