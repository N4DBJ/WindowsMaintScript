# Enhanced Combined System Maintenance Script with Prompts, Logging, Multi-Drive Support, and Expanded Analysis
# Version: 2.3.0
# Last Modified: August 16, 2025
# Author: Grok (Generated by xAI)
# Description: Fixed drive type detection to correctly identify SSDs vs. HDDs, with defrag prompts for non-SSDs only.
#              Includes hardware SMART checks, driver integrity, memory diagnostics, malware scans, update checks,
#              dirty volume queries, and broader Event Log analysis for corruption IDs.

# Must run as Administrator
#Requires -RunAsAdministrator

# Log file setup
$hostname = $env:COMPUTERNAME
$date = Get-Date -Format "yyyyMMdd"
$baseLogFile = "CombinedSystemMaintenanceLog_$hostname_$date"
$logFile = "$baseLogFile.txt"
$counter = 1
while (Test-Path $logFile) {
    $logFile = "${baseLogFile}_$counter.txt"
    $counter++
}
New-Item $logFile -ItemType File | Out-Null

# Function to log messages
function Write-Log {
    param($Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp - $Message" | Out-File -FilePath $logFile -Append
    Write-Host "$timestamp - $Message"
}

# Optional repair source for DISM /restorehealth
$repairSource = $null  # Example: "WIM:D:\sources\install.wim:1"

# Function to prompt user for Yes/No input
function Confirm-Action {
    param (
        [string]$Message,
        [string]$Default = "Y"
    )
    $validChoices = @("Y", "N")
    $choice = Read-Host "$Message (Y/N, default: $Default)"
    $choice = $choice.Trim().ToUpper()
    if (-not $choice) {
        $choice = $Default
    }
    if ($choice -notin $validChoices) {
        Write-Host "Invalid input. Using default: $Default" -ForegroundColor Yellow
        return $Default -eq "Y"
    }
    return $choice -eq "Y"
}

# Check for Sysinternals Suite
$sysinternalsPath = "C:\SysinternalsSuite"
if (-not (Test-Path $sysinternalsPath)) {
    Write-Host "`nSysinternals Suite not found at $sysinternalsPath" -ForegroundColor Yellow
    if (Confirm-Action -Message "Download and extract Sysinternals Suite to $sysinternalsPath and add to PATH?" -Default "N") {
        Write-Log "Downloading Sysinternals Suite..."
        try {
            $zipUrl = "https://download.sysinternals.com/files/SysinternalsSuite.zip"
            $tempZip = [System.IO.Path]::GetTempFileName() + ".zip"
            Invoke-WebRequest -Uri $zipUrl -OutFile $tempZip
            Write-Log "Extracting to $sysinternalsPath..."
            New-Item -Path $sysinternalsPath -ItemType Directory -Force | Out-Null
            Expand-Archive -Path $tempZip -DestinationPath $sysinternalsPath -Force
            Remove-Item -Path $tempZip
            Write-Log "Adding $sysinternalsPath to system PATH..."
            $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine")
            if ($currentPath -notlike "*$sysinternalsPath*") {
                [Environment]::SetEnvironmentVariable("Path", "$currentPath;$sysinternalsPath", "Machine")
            }
            Write-Log "Successfully downloaded and extracted Sysinternals Suite"
        } catch {
            Write-Log "Error downloading Sysinternals Suite: $_"
        }
    } else {
        Write-Log "Skipped Sysinternals Suite download"
    }
}

# Check if Contig is available
$contigAvailable = Get-Command "contig" -ErrorAction SilentlyContinue

# Step 1: Check TRIM status
if (Confirm-Action -Message "Check and enable TRIM for SSD optimization?" -Default "Y") {
    Write-Log "Checking TRIM status..."
    $trimStatus = fsutil behavior query DisableDeleteNotify
    if ($trimStatus -match "DisableDeleteNotify = 0") {
        Write-Log "TRIM is enabled (good for SSD)"
    } else {
        Write-Log "TRIM is disabled. Enabling TRIM..."
        fsutil behavior set DisableDeleteNotify 0
        Write-Log "TRIM enabled"
    }
}

# Step 2: Get all NTFS drives and their types
$physicalDisks = Get-PhysicalDisk | Select-Object DeviceId, MediaType, FriendlyName, UniqueId
$ntfsDrives = Get-Volume | Where-Object { $_.FileSystem -eq "NTFS" -and $_.DriveLetter } | ForEach-Object {
    $volume = $_
    $partition = Get-Partition | Where-Object { $_.DriveLetter -eq $volume.DriveLetter }
    $disk = if ($partition) { Get-Disk -Number ($partition.DiskNumber) } else { $null }
    $mediaType = if ($disk) {
        $physicalDisk = $physicalDisks | Where-Object { $_.UniqueId -eq $disk.UniqueId }
        if ($physicalDisk.MediaType) {
            $physicalDisk.MediaType
        } elseif ($physicalDisk.FriendlyName -match "SSD|NVMe") {
            "SSD"
        } else {
            "HDD"  # Default to HDD if unspecified and no SSD/NVMe in name
        }
    } else {
        "HDD"  # Default if no disk match
    }
    [PSCustomObject]@{
        DriveLetter = $volume.DriveLetter
        MediaType = $mediaType
        FriendlyName = if ($physicalDisk) { $physicalDisk.FriendlyName } else { "Unknown" }
    }
}
if (-not $ntfsDrives) {
    Write-Log "No NTFS drives found. Exiting."
    exit
}
$ssdDrives = $ntfsDrives | Where-Object { $_.MediaType -eq "SSD" } | Select-Object -ExpandProperty DriveLetter
$nonSsdDrives = $ntfsDrives | Where-Object { $_.MediaType -ne "SSD" } | Select-Object -ExpandProperty DriveLetter
Write-Log "Found NTFS drives: $($ntfsDrives.DriveLetter -join ', ')"
Write-Log "SSD drives: $($ssdDrives -join ', ')"
Write-Log "Non-SSD drives: $($nonSsdDrives -join ', ')"
foreach ($drive in $ntfsDrives) {
    Write-Log "Drive $($drive.DriveLetter): MediaType=$($drive.MediaType), FriendlyName=$($drive.FriendlyName)"
}

# OS Maintenance Section
if (Confirm-Action -Message "Proceed with OS Maintenance (DISM and SFC)?" -Default "Y") {
    $osCommands = @(
        @{Command = "dism /online /cleanup-image /checkhealth"; Description = "CheckHealth - Check for component store corruption"},
        @{Command = "dism /online /cleanup-image /scanhealth"; Description = "ScanHealth - Perform a deeper scan for corruption"},
        @{Command = if ($repairSource) { "dism /online /cleanup-image /restorehealth /source:$repairSource" } else { "dism /online /cleanup-image /restorehealth" }; Description = "RestoreHealth - Repair the component store"},
        @{Command = "dism /online /cleanup-image /AnalyzeComponentStore"; Description = "AnalyzeComponentStore - Analyze component store size"},
        @{Command = "dism /online /cleanup-image /StartComponentCleanup"; Description = "StartComponentCleanup - Clean up superseded components"},
        @{Command = "sfc /scannow"; Description = "SFC Scan - Scan and repair system files"}
    )

    foreach ($cmd in $osCommands) {
        Write-Host "`nRunning: $($cmd.Description)" -ForegroundColor Cyan
        if (Confirm-Action -Message "Proceed with $($cmd.Description)?" -Default "Y") {
            Write-Log "Executing: $($cmd.Command)"
            try {
                if ($cmd.Command -eq "sfc /scannow") {
                    $tempFile = [System.IO.Path]::GetTempFileName()
                    Start-Process -FilePath "sfc" -ArgumentList "/scannow" -NoNewWindow -Wait -RedirectStandardOutput $tempFile -RedirectStandardError $tempFile
                    $output = Get-Content $tempFile
                    $output | Write-Host
                    $output | Out-File -FilePath $logFile -Append
                    Remove-Item $tempFile
                } else {
                    $output = Invoke-Expression "$($cmd.Command) 2>&1" | Tee-Object -FilePath $logFile -Append
                }
            } catch {
                Write-Log "Error executing $($cmd.Description): $_"
            }
            Write-Log "End of $($cmd.Description)"
        } else {
            Write-Log "Skipped: $($cmd.Description)"
        }
    }
} else {
    Write-Log "Skipped OS Maintenance section"
}

# Disk Maintenance Section
if (Confirm-Action -Message "Proceed with Disk Maintenance (CHKDSK, fsutil, Contig on all NTFS drives)?" -Default "Y") {
    $contigOutputs = @{}
    $dirtyVolumes = @()
    $lowSpaceDrives = @()
    foreach ($drive in $ntfsDrives.DriveLetter) {
        $drivePath = "$drive`:"
        Write-Log "Processing disk maintenance for $drivePath..."

        # fsutil dirty query
        $dirtyStatus = fsutil dirty query $drivePath
        if ($dirtyStatus -match "IS dirty") {
            Write-Log "$drivePath is marked dirty. Scheduling CHKDSK..."
            $dirtyVolumes += $drivePath
            chkdsk $drivePath /f
        }

        # Free space check
        $volumeInfo = Get-Volume -DriveLetter $drive
        if ($volumeInfo.SizeRemaining / $volumeInfo.Size -lt 0.1) {
            Write-Log "Low free space on $drivePath (<10%). Recommend cleanup."
            $lowSpaceDrives += $drivePath
        }

        # fsutil repair state
        Write-Log "Checking corruption state of $drivePath with fsutil..."
        $repairState = fsutil repair state $drivePath
        $repairState | Out-File -FilePath $logFile -Append
        if ($repairState -match "0x00") {
            Write-Log "$drivePath is clean (0x00). No fsutil/chkdsk repair needed."
        } else {
            Write-Log "$drivePath has corruption ($repairState). Initiating online repair..."
            fsutil repair initiate $drivePath
            Write-Log "Online repair initiated. Scheduling chkdsk /f /sdcleanup..."
            chkdsk $drivePath /f /sdcleanup
            Write-Log "chkdsk /f /sdcleanup scheduled. Reboot may be required."
        }

        # CHKDSK /scan
        $chkdskScanCmd = "chkdsk /scan $drivePath"
        Write-Host "`nRunning CHKDSK Scan on $drivePath" -ForegroundColor Cyan
        if (Confirm-Action -Message "Proceed with CHKDSK Scan on $drivePath?" -Default "Y") {
            Write-Log "Executing: $chkdskScanCmd"
            $output = Invoke-Expression "$chkdskScanCmd 2>&1" | Tee-Object -FilePath $logFile -Append
            Write-Log "End of CHKDSK Scan on $drivePath"
        } else {
            Write-Log "Skipped CHKDSK Scan on $drivePath"
        }

        # Contig on MFT
        if ($contigAvailable) {
            $contigCmd = "contig -v -s $drivePath\`$MFT"
            Write-Host "`nRunning Contig on MFT for $drivePath" -ForegroundColor Cyan
            if (Confirm-Action -Message "Proceed with Contig on MFT for $drivePath?" -Default "Y") {
                Write-Log "Executing: $contigCmd"
                $output = Invoke-Expression "$contigCmd 2>&1" | Tee-Object -FilePath $logFile -Append
                $contigOutputs[$drivePath] = $output
                Write-Log "End of Contig on $drivePath"
            } else {
                Write-Log "Skipped Contig on $drivePath"
            }
        } else {
            Write-Log "Contig not available. Skipping MFT defragmentation for $drivePath."
        }
    }
    if ($dirtyVolumes.Count -gt 0) {
        Write-Log "Dirty volumes found: $($dirtyVolumes -join ', '). Reboot to fix."
    }
} else {
    Write-Log "Skipped Disk Maintenance section"
}

# Shadow Copy Maintenance Section
if (Confirm-Action -Message "Proceed with Shadow Copy Maintenance (check and fix corruption on all NTFS drives)?" -Default "Y") {
    $shadowStates = @{}
    foreach ($drive in $ntfsDrives.DriveLetter) {
        $drivePath = "$drive`:"
        Write-Log "Processing shadow copy maintenance for $drivePath..."

        $shadowList = vssadmin list shadows /for=$drivePath
        $shadowList | Out-File -FilePath $logFile -Append
        $shadowCopies = $shadowList | Select-String "Shadow Copy ID: {(.+?)}" | ForEach-Object { $_.Matches.Groups[1].Value }
        $shadowVolumes = $shadowList | Select-String "Shadow Copy Volume: (.+?)$" | ForEach-Object { $_.Matches.Groups[1].Value }

        if ($shadowCopies) {
            Write-Log "Found $($shadowCopies.Count) shadow copies for $drivePath."
            $driveShadowStates = @()
            for ($i = 0; $i -lt $shadowCopies.Count; $i++) {
                $shadowId = $shadowCopies[$i]
                $shadowVolume = $shadowVolumes[$i]
                Write-Log "Checking corruption state of shadow copy: $shadowVolume (ID: $shadowId)"
                $shadowRepairState = fsutil repair state $shadowVolume
                $shadowRepairState | Out-File -FilePath $logFile -Append
                $driveShadowStates += $shadowRepairState
                if ($shadowRepairState -match "0x00") {
                    Write-Log "Shadow copy $shadowVolume is clean (0x00)."
                } else {
                    Write-Log "Shadow copy $shadowVolume is corrupted ($shadowRepairState). Deleting..."
                    vssadmin delete shadows /shadow=$shadowId /quiet
                    Write-Log "Deleted corrupted shadow copy $shadowId for $drivePath."
                }
            }
            $shadowStates[$drivePath] = $driveShadowStates
        } else {
            Write-Log "No shadow copies found for $drivePath."
        }
    }

    if ($ntfsDrives.DriveLetter -contains "C" -and ($shadowStates.Values | ForEach-Object { $_ | Select-String "0x00" -NotMatch })) {
        Write-Log "Creating new restore point for C:..."
        try {
            Checkpoint-Computer -Description "Post-ShadowCopyCleanup Restore Point $((Get-Date -Format 'yyyy-MM-dd HH:mm:ss'))" -RestorePointType MODIFY_SETTINGS
            Write-Log "New restore point created successfully for C:."
        } catch {
            Write-Log "Error creating restore point for C:: $_"
        }
    }
} else {
    Write-Log "Skipped Shadow Copy Maintenance section"
}

# Optimization Section (defrag with drive type check)
if (Confirm-Action -Message "Proceed with Drive Optimization (defrag /C /O /V for SSDs, prompt for non-SSDs)?" -Default "Y") {
    Write-Log "Checking drive types for optimization..."
    if ($ssdDrives) {
        Write-Log "Running defrag /C /O /V for SSD drives: $($ssdDrives -join ', ')"
        $defragOutput = defrag /C /O /V 2>&1  # TRIM for SSDs
        $defragOutput | Out-File -FilePath $logFile -Append
        Write-Log "SSD optimization (TRIM) completed."
    }
    if ($nonSsdDrives) {
        Write-Log "Non-SSD drives detected: $($nonSsdDrives -join ', '). Defragmentation may take significant time."
        if (Confirm-Action -Message "Proceed with defrag /C /O /V for non-SSD drives (may be time-consuming)?" -Default "N") {
            Write-Log "Running defrag /C /O /V for non-SSD drives..."
            $defragOutput = defrag /C /O /V 2>&1
            $defragOutput | Out-File -FilePath $logFile -Append
            Write-Log "Non-SSD defragmentation completed."
        } else {
            Write-Log "Skipped defragmentation for non-SSD drives."
        }
    }
    if (-not $ssdDrives -and -not $nonSsdDrives) {
        Write-Log "No drives eligible for optimization."
    }
} else {
    Write-Log "Skipped Drive Optimization section"
}

# Hardware and Driver Checks Section
if (Confirm-Action -Message "Proceed with Hardware and Driver Checks (SMART, drivers)?" -Default "Y") {
    $physicalDisks = Get-PhysicalDisk
    $reliability = $physicalDisks | Get-StorageReliabilityCounter
    $smartIssues = 0
    foreach ($disk in $physicalDisks) {
        if ($disk.HealthStatus -ne "Healthy") {
            Write-Log "Unhealthy disk: $($disk.DeviceId) - Status: $($disk.HealthStatus)"
            $smartIssues++
        }
    }
    foreach ($counter in $reliability) {
        if ($counter.ReadErrorsTotal -gt 0 -or $counter.WriteErrorsTotal -gt 0 -or $counter.Wear -gt 90) {
            Write-Log "SMART issues on disk: ReadErrors=$($counter.ReadErrorsTotal), WriteErrors=$($counter.WriteErrorsTotal), Wear=$($counter.Wear)%"
            $smartIssues++
        }
    }
    if ($smartIssues -gt 0) {
        Write-Log "Recommend running full hardware diagnostics (e.g., CrystalDiskInfo)."
    }

    $problemDrivers = Get-WmiObject Win32_PnPSignedDriver | Where-Object { $_.Status -ne "OK" -or -not $_.IsSigned }
    if ($problemDrivers) {
        Write-Log "Problem drivers found: $($problemDrivers.Count). Running pnputil /scan-devices..."
        pnputil /scan-devices
    }
} else {
    Write-Log "Skipped Hardware and Driver Checks"
}

# Memory and Update Checks Section
if (Confirm-Action -Message "Proceed with Memory and Update Checks?" -Default "Y") {
    $pendingReboot = Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired"
    if ($pendingReboot) {
        Write-Log "Pending reboot detected. Recommend reboot after script."
    }

    $failedUpdates = Get-HotFix | Where-Object { $_.Status -ne "Succeeded" }
    if ($failedUpdates) {
        Write-Log "Failed updates found: $($failedUpdates.Count). Running wuauclt /detectnow..."
        wuauclt /detectnow
    }

    if (Confirm-Action -Message "Schedule Windows Memory Diagnostic on next reboot?" -Default "N") {
        mdsched.exe /scheduleboot
        Write-Log "Memory Diagnostic scheduled on next reboot."
    }
} else {
    Write-Log "Skipped Memory and Update Checks"
}

# Malware Scan Section
if (Confirm-Action -Message "Proceed with Quick Malware Scan (Windows Defender)?" -Default "Y") {
    Write-Log "Running Quick Malware Scan..."
    Start-MpScan -ScanType QuickScan
    $defenderEvents = Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=@(1000,1001); StartTime=(Get-Date).AddHours(-1)} -ErrorAction SilentlyContinue
    $threats = $defenderEvents | Where-Object { $_.Message -match "threat detected" }
    if ($threats) {
        Write-Log "Threats detected: $($threats.Count). Recommend full scan."
    } else {
        Write-Log "No threats found in quick scan."
    }
} else {
    Write-Log "Skipped Malware Scan"
}

# Verify VSS service
Write-Log "Checking Volume Shadow Copy Service (VSS) status..."
$vssStatus = Get-Service -Name VSS
if ($vssStatus.Status -eq "Running") {
    Write-Log "VSS service is running."
} else {
    Write-Log "VSS service is not running. Starting VSS..."
    Start-Service -Name VSS
    Write-Log "VSS service started."
}

# Log and Event Log Analysis Section
if (Confirm-Action -Message "Proceed with expanded log analysis?" -Default "Y") {
    $dismLogPath = "$env:windir\Logs\DISM\dism.log"
    $cbsLogPath = "$env:windir\Logs\CBS\cbs.log"
    
    $dismErrors = 0
    $dismRepairs = 0
    $cbsErrors = 0
    $cbsRepairs = 0
    $chkdskErrors = 0
    $chkdskRepairs = 0
    $contigErrorsPerDrive = @{}
    $contigFragmentsPerDrive = @{}
    $fsutilCorruptedDrives = 0
    $shadowCorrupted = 0
    $defragErrors = 0
    $defragOptimizations = 0
    $diskErrors = 0
    $driverErrors = 0
    $hardwareErrors = 0
    $vssErrors = 0
    
    $errorPattern = "error|failed|failure|corrupt"
    $repairPattern = "repaired|restored|fixed|successfully repaired"
    $chkdskErrorPattern = "found \d+ bad|corruption|error"
    $chkdskRepairPattern = "repaired|fixed|corrected|cleaned"
    $contigErrorPattern = "error|failed|cannot open"
    $contigFragmentPattern = "is in (\d+) fragments"
    $fsutilCorruptionPattern = "0x[1-9A-F]"
    $shadowCorruptionPattern = "0x[1-9A-F]"
    $defragErrorPattern = "error|failed"
    $defragOptPattern = "optimized|trimmed|defragmented"
    
    if (Test-Path $dismLogPath) {
        $dismErrors = (Select-String -Path $dismLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $dismRepairs = (Select-String -Path $dismLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
    } else {
        Write-Log "DISM.log not found at $dismLogPath"
    }
    
    if (Test-Path $cbsLogPath) {
        $cbsErrors = (Select-String -Path $cbsLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $cbsRepairs = (Select-String -Path $cbsLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
    } else {
        Write-Log "CBS.log not found at $cbsLogPath"
    }
    
    $eventIds = @(7,11,50,55,98,137,140,153,219,41,7023,2004,1001,12289,12290)
    $systemEvents = Get-WinEvent -FilterHashtable @{LogName='System'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $appEvents = Get-WinEvent -FilterHashtable @{LogName='Application'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $allEvents = $systemEvents + $appEvents

    $diskErrors = $allEvents | Where-Object { $_.Id -in @(7,11,50,55,98,137,140,153) } | Measure-Object | Select -Expand Count
    $driverErrors = $allEvents | Where-Object { $_.Id -in @(219,7023) } | Measure-Object | Select -Expand Count
    $hardwareErrors = $allEvents | Where-Object { $_.Id -in @(41,2004,1001) } | Measure-Object | Select -Expand Count
    $vssErrors = $allEvents | Where-Object { $_.Id -in @(12289,12290) } | Measure-Object | Select -Expand Count
    
    foreach ($drivePath in $contigOutputs.Keys) {
        $output = $contigOutputs[$drivePath]
        $contigErrorsPerDrive[$drivePath] = ($output | Select-String -Pattern $contigErrorPattern -CaseSensitive:$false | Measure-Object).Count
        $fragmentMatch = $output | Select-String -Pattern $contigFragmentPattern -CaseSensitive:$false
        if ($fragmentMatch) {
            $contigFragmentsPerDrive[$drivePath] = [int]($fragmentMatch.Matches.Groups[1].Value)
        } else {
            $contigFragmentsPerDrive[$drivePath] = 0
        }
    }
    
    $fsutilCorruptedDrives = (Select-String -Path $logFile -Pattern $fsutilCorruptionPattern | Measure-Object).Count
    foreach ($states in $shadowStates.Values) {
        $shadowCorrupted += ($states | Select-String -Pattern $shadowCorruptionPattern | Measure-Object).Count
    }
    $defragErrors = (Select-String -Path $logFile -Pattern $defragErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $defragOptimizations = (Select-String -Path $logFile -Pattern $defragOptPattern -CaseSensitive:$false | Measure-Object).Count
    
    $totalErrors = $dismErrors + $cbsErrors + $chkdskErrors + ($contigErrorsPerDrive.Values | Measure-Object -Sum).Sum + $fsutilCorruptedDrives + $shadowCorrupted + $defragErrors + $diskErrors + $driverErrors + $hardwareErrors + $vssErrors
    $totalRepairs = $dismRepairs + $cbsRepairs + $chkdskRepairs + $defragOptimizations
    
    Write-Host "`nLog Analysis Summary:" -ForegroundColor Green
    Write-Host "DISM.log Errors/Failures: $dismErrors"
    Write-Host "DISM.log Repairs: $dismRepairs"
    Write-Host "CBS.log Errors/Failures: $cbsErrors"
    Write-Host "CBS.log Repairs: $cbsRepairs"
    Write-Host "CHKDSK Event Log Errors: $chkdskErrors"
    Write-Host "CHKDSK Event Log Repairs: $chkdskRepairs"
    foreach ($drivePath in $contigErrorsPerDrive.Keys) {
        $driveType = ($ntfsDrives | Where-Object { $_.DriveLetter -eq $drivePath[0] }).MediaType
        Write-Host "Contig Errors on $drivePath ($driveType): $($contigErrorsPerDrive[$drivePath])"
        Write-Host "Contig MFT Fragments on $drivePath ($driveType): $($contigFragmentsPerDrive[$drivePath])"
    }
    Write-Host "fsutil Corrupted Drives: $fsutilCorruptedDrives"
    Write-Host "Shadow Copy Corrupted Instances: $shadowCorrupted"
    Write-Host "Defrag Errors: $defragErrors"
    Write-Host "Defrag Optimizations: $defragOptimizations"
    Write-Host "Disk/NTFS Errors (IDs 7,11,50,55,98,137,140,153): $diskErrors"
    Write-Host "Driver Errors (IDs 219,7023): $driverErrors"
    Write-Host "Hardware/Memory Errors (IDs 41,2004,1001): $hardwareErrors"
    Write-Host "VSS Errors (IDs 12289,12290): $vssErrors"
    Write-Host "Total Errors/Failures: $totalErrors"
    Write-Host "Total Repairs/Optimizations: $totalRepairs"

    $recommendations = @()
    if ($diskErrors -gt 0) { $recommendations += "Run full CHKDSK /f /r on affected drives (caution on SSDs)." }
    if ($smartIssues -gt 0) { $recommendations += "Check hardware with manufacturer tools (e.g., CrystalDiskInfo)." }
    if ($driverErrors -gt 0) { $recommendations += "Update or rollback drivers via Device Manager." }
    if ($hardwareErrors -gt 0) { $recommendations += "Run memory/hardware diagnostics." }
    if ($vssErrors -gt 0) { $recommendations += "Restart VSS service or clear shadow storage." }
    if ($lowSpaceDrives.Count -gt 0) { $recommendations += "Free up space on $($lowSpaceDrives -join ', ')." }
    if ($threats) { $recommendations += "Run full Defender scan." }
    if ($recommendations) {
        Write-Host "Recommendations:" -ForegroundColor Yellow
        $recommendations | ForEach-Object { Write-Host "- $_" }
    }

    # Append to log
    "----- Log Analysis Summary at $(Get-Date) -----" | Out-File -FilePath $logFile -Append
    "DISM.log Errors/Failures: $dismErrors" | Out-File -FilePath $logFile -Append
    "DISM.log Repairs: $dismRepairs" | Out-File -FilePath $logFile -Append
    "CBS.log Errors/Failures: $cbsErrors" | Out-File -FilePath $logFile -Append
    "CBS.log Repairs: $cbsRepairs" | Out-File -FilePath $logFile -Append
    "CHKDSK Event Log Errors: $chkdskErrors" | Out-File -FilePath $logFile -Append
    "CHKDSK Event Log Repairs: $chkdskRepairs" | Out-File -FilePath $logFile -Append
    foreach ($drivePath in $contigErrorsPerDrive.Keys) {
        $driveType = ($ntfsDrives | Where-Object { $_.DriveLetter -eq $drivePath[0] }).MediaType
        "Contig Errors on $drivePath ($driveType): $($contigErrorsPerDrive[$drivePath])" | Out-File -FilePath $logFile -Append
        "Contig MFT Fragments on $drivePath ($driveType): $($contigFragmentsPerDrive[$drivePath])" | Out-File -FilePath $logFile -Append
    }
    "fsutil Corrupted Drives: $fsutilCorruptedDrives" | Out-File -FilePath $logFile -Append
    "Shadow Copy Corrupted Instances: $shadowCorrupted" | Out-File -FilePath $logFile -Append
    "Defrag Errors: $defragErrors" | Out-File -FilePath $logFile -Append
    "Defrag Optimizations: $defragOptimizations" | Out-File -FilePath $logFile -Append
    "Disk/NTFS Errors (IDs 7,11,50,55,98,137,140,153): $diskErrors" | Out-File -FilePath $logFile -Append
    "Driver Errors (IDs 219,7023): $driverErrors" | Out-File -FilePath $logFile -Append
    "Hardware/Memory Errors (IDs 41,2004,1001): $hardwareErrors" | Out-File -FilePath $logFile -Append
    "VSS Errors (IDs 12289,12290): $vssErrors" | Out-File -FilePath $logFile -Append
    "Total Errors/Failures: $totalErrors" | Out-File -FilePath $logFile -Append
    "Total Repairs/Optimizations: $totalRepairs" | Out-File -FilePath $logFile -Append
    if ($recommendations) {
        "Recommendations:" | Out-File -FilePath $logFile -Append
        $recommendations | ForEach-Object { "- $_" | Out-File -FilePath $logFile -Append }
    }
    "----- End of Log Analysis -----" | Out-File -FilePath $logFile -Append
} else {
    Write-Log "Skipped Log Analysis"
}

Write-Host "`nAll operations completed. Log file: $logFile" -ForegroundColor Cyan
pause