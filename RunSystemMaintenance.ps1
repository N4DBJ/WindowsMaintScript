# System Maintenance Script with Prompts, Logging, and Log/Event Analysis
# Version: 1.8.0
# Last Modified: August 15, 2025
# Author: Grok (Generated by xAI)
# Description: Executes a series of system maintenance commands (DISM, SFC, CHKDSK, Contig) with user prompts,
#              logs output to a file named with hostname and date, and analyzes DISM.log, CBS.log, Event Log,
#              and Contig output for errors, repairs, and MFT fragment counts. Supports log rotation, an optional
#              repair source for DISM /restorehealth, MFT defragmentation with Contig on a user-specified drive,
#              real-time progress output for sfc /scannow, and additional CHKDSK /f /sdcleanup command.

# Get hostname and current date for log filename
$hostname = $env:COMPUTERNAME
$date = Get-Date -Format "yyyyMMdd"
$baseLogFile = "SystemMaintenanceLog_$hostname_$date"

# Determine log file path with rotation (append _N if file exists)
$logFile = "$baseLogFile.txt"
$counter = 1
while (Test-Path $logFile) {
    $logFile = "${baseLogFile}_$counter.txt"
    $counter++
}

# Initialize the log file
New-Item $logFile -ItemType File | Out-Null

# Optional repair source for DISM /restorehealth (e.g., 'WIM:X:\sources\install.wim:1')
# Set to $null or empty string to use Windows Update (default)
$repairSource = $null  # Example: "WIM:D:\sources\install.wim:1"

# Function to prompt user for Yes/No input with a configurable default
function Confirm-Action {
    param (
        [string]$Message,        # The prompt message displayed to the user
        [string]$Default = "Y"   # Default response (Y or N) if user presses Enter
    )
    # Define valid input choices
    $validChoices = @("Y", "N")
    # Read user input and normalize to uppercase
    $choice = Read-Host "$Message (Y/N, default: $Default)"
    $choice = $choice.Trim().ToUpper()
    
    # If no input is provided, use the default
    if (-not $choice) {
        $choice = $Default
    }
    
    # Validate input; if invalid, inform user and use default
    if ($choice -notin $validChoices) {
        Write-Host "Invalid input. Using default: $Default" -ForegroundColor Yellow
        return $Default -eq "Y"
    }
    
    # Return true for "Y", false for "N"
    return $choice -eq "Y"
}

# Function to validate and get drive letter for Contig
function Get-ValidDriveLetter {
    param (
        [string]$Default = "C"  # Default drive letter
    )
    # Prompt user for drive letter
    $drive = Read-Host "Enter drive letter for Contig MFT defragmentation (default: $Default)"
    $drive = $drive.Trim().ToUpper()
    
    # Use default if no input provided
    if (-not $drive) {
        $drive = $Default
    }
    
    # Validate drive letter (must be a single letter followed by a colon, e.g., "C:")
    if ($drive -notmatch '^[A-Z]:$') {
        Write-Host "Invalid drive letter. Using default: $Default" -ForegroundColor Yellow
        return "$Default"
    }
    
    # Check if drive exists
    if (-not (Test-Path "$drive\")) {
        Write-Host "Drive $drive does not exist. Using default: $Default" -ForegroundColor Yellow
        return "$Default"
    }
    
    return $drive
}

# Define array of system maintenance commands with descriptions
$commands = @(
    @{Command = "dism /online /cleanup-image /checkhealth"; Description = "CheckHealth - Check for component store corruption"},
    @{Command = "dism /online /cleanup-image /scanhealth"; Description = "ScanHealth - Perform a deeper scan for corruption"},
    @{Command = if ($repairSource) { "dism /online /cleanup-image /restorehealth /source:$repairSource" } else { "dism /online /cleanup-image /restorehealth" }; Description = "RestoreHealth - Repair the component store"},
    @{Command = "dism /online /cleanup-image /AnalyzeComponentStore"; Description = "AnalyzeComponentStore - Analyze component store size"},
    @{Command = "dism /online /cleanup-image /StartComponentCleanup"; Description = "StartComponentCleanup - Clean up superseded components"},
    @{Command = "sfc /scannow"; Description = "SFC Scan - Scan and repair system files"},
    @{Command = "chkdsk /scan c:"; Description = "CheckDisk Scan - Scan C: drive for errors"},
    @{Command = "chkdsk /f /sdcleanup c:"; Description = "CheckDisk Fix - Fix errors and clean up security descriptors on C: drive"}
)

# Prompt for drive letter for Contig before adding it to commands
$contigDrive = Get-ValidDriveLetter -Default "C"
$contigCommand = "contig -v -s $($contigDrive):\`$MFT"
# Variable to store Contig output for analysis
$contigOutput = $null
# Check if contig is available
if (-not (Get-Command "contig" -ErrorAction SilentlyContinue)) {
    Write-Host "Contig not found in PATH. Please download from Sysinternals (https://learn.microsoft.com/sysinternals/downloads/contig) and add to PATH." -ForegroundColor Red
    "Contig not found. Download from https://learn.microsoft.com/sysinternals/downloads/contig" | Out-File -FilePath $logFile -Append
} else {
    # Add Contig command to the array
    $commands += @{Command = $contigCommand; Description = "Contig - Defragment MFT on drive $contigDrive"}
}

# Execute each command with user confirmation
foreach ($cmd in $commands) {
    # Display the command being considered
    Write-Host "`nRunning: $($cmd.Description)" -ForegroundColor Cyan
    # Prompt user for confirmation
    if (Confirm-Action -Message "Proceed with $($cmd.Description)?" -Default "Y") {
        Write-Host "Executing: $($cmd.Command)" -ForegroundColor Green
        # Log command start with timestamp
        "----- Executing: $($cmd.Command) at $(Get-Date) -----" | Out-File -FilePath $logFile -Append
        try {
            if ($cmd.Command -eq "sfc /scannow") {
                # Use Start-Process for sfc /scannow to show progress in console
                $tempFile = [System.IO.Path]::GetTempFileName()
                Start-Process -FilePath "sfc" -ArgumentList "/scannow" -NoNewWindow -Wait -RedirectStandardOutput $tempFile -RedirectStandardError $tempFile
                # Read and display output, then append to log
                $output = Get-Content $tempFile
                $output | Write-Host
                $output | Out-File -FilePath $logFile -Append
                Remove-Item $tempFile
            } else {
                # Execute other commands, capture stdout/stderr, display to console, and log to file
                $output = Invoke-Expression "$($cmd.Command) 2>&1" | Tee-Object -FilePath $logFile -Append
                # If Contig command, store output for analysis
                if ($cmd.Command -eq $contigCommand) {
                    $contigOutput = $output
                }
            }
        } catch {
            # Handle and log any execution errors
            Write-Host "Error executing $($cmd.Description): $_" -ForegroundColor Red
            "Error: $_" | Out-File -FilePath $logFile -Append
        }
        # Log command completion
        "----- End of $($cmd.Description) -----" | Out-File -FilePath $logFile -Append
    } else {
        # Log and notify if command is skipped
        Write-Host "Skipped: $($cmd.Description)" -ForegroundColor Yellow
        "Skipped: $($cmd.Description)" | Out-File -FilePath $logFile -Append
    }
}

# Log and Event Log Analysis Section
Write-Host "`nLog Analysis" -ForegroundColor Cyan
if (Confirm-Action -Message "Proceed with analyzing DISM.log, CBS.log, Event Log, and Contig output for errors and repairs?" -Default "Y") {
    # Define paths for DISM and CBS logs
    $dismLogPath = "$env:windir\Logs\DISM\dism.log"
    $cbsLogPath = "$env:windir\Logs\CBS\cbs.log"
    
    # Initialize counters for errors and repairs
    $dismErrors = 0
    $dismRepairs = 0
    $cbsErrors = 0
    $cbsRepairs = 0
    $chkdskErrors = 0
    $chkdskRepairs = 0
    $contigErrors = 0
    $contigFragments = 0
    
    # Define patterns for detecting errors and repairs (case-insensitive)
    $errorPattern = "error|failed|failure|corrupt"
    $repairPattern = "repaired|restored|fixed|successfully repaired"
    $chkdskErrorPattern = "found \d+ bad|corruption|error"
    $chkdskRepairPattern = "repaired|fixed|corrected|cleaned"
    $contigErrorPattern = "error|failed|cannot open"
    $contigFragmentPattern = "is in (\d+) fragments"
    
    # Analyze DISM.log for errors and repairs
    if (Test-Path $dismLogPath) {
        $dismErrors = (Select-String -Path $dismLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $dismRepairs = (Select-String -Path $dismLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
    } else {
        Write-Host "DISM.log not found at $dismLogPath" -ForegroundColor Yellow
        "DISM.log not found" | Out-File -FilePath $logFile -Append
    }
    
    # Analyze CBS.log for errors and repairs
    if (Test-Path $cbsLogPath) {
        $cbsErrors = (Select-String -Path $cbsLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $cbsRepairs = (Select-String -Path $cbsLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
    } else {
        Write-Host "CBS.log not found at $cbsLogPath" -ForegroundColor Yellow
        "CBS.log not found" | Out-File -FilePath $logFile -Append
    }
    
    # Analyze Event Log for CHKDSK (Wininit, Event ID 1001)
    try {
        # Query recent CHKDSK events (last 24 hours, max 10 events)
        $chkdskEvents = Get-WinEvent -LogName "Application" -FilterXPath "*[System[Provider[@Name='Wininit'] and EventID=1001]]" -MaxEvents 10 -ErrorAction Stop | 
            Where-Object { $_.TimeCreated -ge (Get-Date).AddHours(-24) }
        foreach ($event in $chkdskEvents) {
            # Parse event message for errors and repairs
            $eventMessage = $event.Message
            $chkdskErrors += (Select-String -InputObject $eventMessage -Pattern $chkdskErrorPattern -CaseSensitive:$false | Measure-Object).Count
            $chkdskRepairs += (Select-String -InputObject $eventMessage -Pattern $chkdskRepairPattern -CaseSensitive:$false | Measure-Object).Count
        }
    } catch {
        # Handle errors accessing Event Log
        Write-Host "Error accessing Event Log for CHKDSK analysis: $_" -ForegroundColor Red
        "Error accessing Event Log for CHKDSK: $_" | Out-File -FilePath $logFile -Append
    }
    
    # Analyze Contig output for errors and fragment count
    if ($contigOutput) {
        $contigErrors = ($contigOutput | Select-String -Pattern $contigErrorPattern -CaseSensitive:$false | Measure-Object).Count
        $fragmentMatch = $contigOutput | Select-String -Pattern $contigFragmentPattern -CaseSensitive:$false
        if ($fragmentMatch) {
            $contigFragments = [int]($fragmentMatch.Matches.Groups[1].Value)
        }
    } elseif ($contigOutput -eq $null -and (Get-Command "contig" -ErrorAction SilentlyContinue)) {
        Write-Host "Contig output not available (command may have been skipped)." -ForegroundColor Yellow
        "Contig output not available (command may have been skipped)." | Out-File -FilePath $logFile -Append
    }
    
    # Calculate total errors and repairs
    $totalErrors = $dismErrors + $cbsErrors + $chkdskErrors + $contigErrors
    $totalRepairs = $dismRepairs + $cbsRepairs + $chkdskRepairs
    
    # Display analysis summary to console
    Write-Host "`nLog Analysis Summary:" -ForegroundColor Green
    Write-Host "DISM.log Errors/Failures: $dismErrors"
    Write-Host "DISM.log Repairs: $dismRepairs"
    Write-Host "CBS.log Errors/Failures: $cbsErrors"
    Write-Host "CBS.log Repairs: $cbsRepairs"
    Write-Host "CHKDSK Event Log Errors: $chkdskErrors"
    Write-Host "CHKDSK Event Log Repairs: $chkdskRepairs"
    Write-Host "Contig Errors: $contigErrors"
    Write-Host "Contig MFT Fragments: $contigFragments"
    Write-Host "Total Errors/Failures: $totalErrors"
    Write-Host "Total Repairs: $totalRepairs"
    
    # Append analysis summary to log file
    "----- Log Analysis Summary at $(Get-Date) -----" | Out-File -FilePath $logFile -Append
    "DISM.log Errors/Failures: $dismErrors" | Out-File -FilePath $logFile -Append
    "DISM.log Repairs: $dismRepairs" | Out-File -FilePath $logFile -Append
    "CBS.log Errors/Failures: $cbsErrors" | Out-File -FilePath $logFile -Append
    "CBS.log Repairs: $cbsRepairs" | Out-File -FilePath $logFile -Append
    "CHKDSK Event Log Errors: $chkdskErrors" | Out-File -FilePath $logFile -Append
    "CHKDSK Event Log Repairs: $chkdskRepairs" | Out-File -FilePath $logFile -Append
    "Contig Errors: $contigErrors" | Out-File -FilePath $logFile -Append
    "Contig MFT Fragments: $contigFragments" | Out-File -FilePath $logFile -Append
    "Total Errors/Failures: $totalErrors" | Out-File -FilePath $logFile -Append
    "Total Repairs: $totalRepairs" | Out-File -FilePath $logFile -Append
    "----- End of Log Analysis -----" | Out-File -FilePath $logFile -Append
} else {
    # Log and notify if analysis is skipped
    Write-Host "Skipped: Log Analysis" -ForegroundColor Yellow
    "Skipped: Log Analysis" | Out-File -FilePath $logFile -Append
}

# Notify user of completion and log file location
Write-Host "`nAll operations completed. Log file: $logFile" -ForegroundColor Cyan
pause