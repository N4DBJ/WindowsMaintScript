# WinSystemMaintenance_2.8.3.ps1
# Enhanced Combined System Maintenance Script with Prompts, Logging, Multi-Drive Support, and Expanded Analysis
# Version: 2.8.3
# Last Modified: August 19, 2025
# Author: Grok (Generated by xAI)
# Description: Comprehensive system maintenance script for Windows 10/11 and Server 2019+, including OS maintenance (DISM, SFC),
#              disk maintenance (CHKDSK, fsutil, Contig), shadow copy maintenance, drive optimization (defrag),
#              temp file cleanup, hardware/driver checks, memory/update checks, malware scan, and log analysis.

# Changelog:
#   2.8.3 (2025-08-19):
#     - Fixed truncation in Log Analysis section: completed pattern matching for cleanup and defender errors.
#     - Added counts for CHKDSK errors and repairs in Log Analysis.
#     - Enhanced Log Analysis with Windows Server-specific patterns (e.g., WSUS-related errors).
#     - Completed Final Summary section with all summary variables, recommendations, and script version.
#     - Added OS compatibility checks for Windows 10/11 and Server 2019+ (skips non-applicable features like memory diagnostic on servers).
#     - Improved error handling in process starts (added -Wait where needed).
#     - Updated README.md (assumed external) with server usage notes.
#     - Retained all fixes from 2.7.6, including syntax corrections in Log Analysis and Final Summary.
#   2.7.6 (2025-08-17):
#     - Fixed syntax error in Log Analysis section: missing string terminator in Write-Log summary statement.
#     - Fixed missing closing brace for Log Analysis 'if' block.
#     - Updated CHANGELOG.md to document version 2.7.6 fixes.
#     - Updated README.md to enhance syntax validation instructions with specific PSScriptAnalyzer rules.
#     - Retained all fixes from 2.7.5, including completed Log Analysis and Final Summary sections.
#   2.7.5 (2025-08-17):
#     - Fixed syntax errors in Log Analysis section: missing string terminators in Write-Log and Write-Host statements.
#     - Fixed missing closing brace for Log Analysis 'if' block.
#     - Updated CHANGELOG.md to document version 2.7.5 fixes.
#     - Updated README.md to enhance syntax validation instructions with PSScriptAnalyzer.
#     - Retained all fixes from 2.7.4, including completed Log Analysis and Final Summary sections.
#   2.7.4 (2025-08-17):
#     - Fixed syntax errors in Log Analysis section (missing closing parenthesis, string terminator, and braces).
#     - Completed Log Analysis section to properly display Contig errors and fragments.
#     - Completed Final Summary section with all summary variables and recommendations.
#     - Added comment to confirm closure of all script blocks.
#     - Updated README.md with syntax validation instructions.
#     - Retained all fixes from 2.7.3, including completed Final Summary section.
#   2.7.3 (2025-08-17):
#     - Fixed syntax error in Final Summary section (missing closing quote in Write-Log statement).
#     - Completed Final Summary section to include all summary variables and recommendations.
#     - Retained all fixes from 2.7.2, including Log Analysis section corrections.
#   2.7.2 (2025-08-17):
#     - Fixed syntax error in Log Analysis section (missing closing brace for 'if' block at Confirm-Action).
#     - Completed Final Summary section to include all summary variables and script version logging.
#     - Retained all fixes from 2.7.1, including Malware Scan section corrections.
#   2.7.1 (2025-08-17):
#     - Fixed syntax error in Malware Scan section (incomplete hash literal in Get-WinEvent, missing catch block, and unclosed braces).
#     - Restored Log Analysis and Final Summary sections that were truncated.
#     - Retained all features from 2.7.0, including $scriptVersion variable and Final Summary display/logging.
#   2.7.0 (2025-08-17):
#     - Added $scriptVersion variable to manage version display in one place.
#     - Added script version display in new Final Summary section at end of execution.
#     - Added script version to Final Summary in log file.
#     - Retained UTF-8 encoding for all log writes from 2.5.9.
#     - Retained Write-Log function placement fix from 2.6.0.
#   2.6.0 (2025-08-16):
#     - Fixed 'Write-Log' not recognized error by moving function definition before first use.
#     - Retained UTF-8 encoding for all log writes from 2.5.9 to resolve "Unsupported text encoding" upload issues.
#     - Retained streamlined logging from 2.5.8 (task start, command, filtered output, result, summary only).
#     - Retained script version logging at start ("Script Version: 2.6.0").
#     - Retained Windows 11-specific error patterns and recommendations in Log Analysis section.
#   2.5.9 (2025-08-16):
#     - Changed log file encoding to UTF-8 for all writes to resolve "Unsupported text encoding" upload issues.
#     - Retained streamlined logging from 2.5.8 (task start, command, filtered output, result, summary only).
#     - Retained script version logging at start ("Script Version: 2.5.9").
#     - Retained Windows 11-specific error patterns and recommendations in Log Analysis section.
#   2.5.8 (2025-08-16):
#     - Added script version to log file at start.
#     - Enhanced Log Analysis section with Windows 11-specific error/repair patterns and recommendations.
#     - Streamlined logging to remove redundant status lines (e.g., repetitive progress, "End of" unless critical).
#     - Enhanced console output in OS Maintenance to clearly display DISM results (e.g., "Result: Success: No corruption detected").
#     - Added full command to description line for each step (e.g., "dism /online /cleanup-image /checkhealth").
#   2.5.7 (2025-08-16):
#     - Added timeout (1 hour) and stalled progress detection (10 min) for DISM /restorehealth to prevent hangs.
#     - Added pre-check for internet connectivity if no repair source is specified.
#     - Added prompt to run SFC /scannow before /restorehealth if not already run.
#     - Added script version display in console.
#     - Fixed DISM command execution error by updating $osCommands to store only arguments and adjusting Start-Process.

# Must run as Administrator
#Requires -RunAsAdministrator

# Define script version - This variable is used throughout the script to display and log the current version.
$scriptVersion = "2.8.3"

# Display script version in console for user awareness.
Write-Host "Script Version: $scriptVersion" -ForegroundColor Cyan

# Function to log messages - This function appends timestamped messages to the log file and displays them in the console.
function Write-Log {
    param($Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp - $Message" | Out-File -FilePath $logFile -Append -Encoding UTF8
    Write-Host "$timestamp - $Message"
}

# Log file setup - Creates a unique log file based on hostname and date to avoid overwriting previous logs.
$hostname = $env:COMPUTERNAME
$date = Get-Date -Format "yyyyMMdd"
$baseLogFile = "CombinedSystemMaintenanceLog_$hostname_$date"
$logFile = "$baseLogFile.txt"
$counter = 1
while (Test-Path $logFile) {
    $logFile = "${baseLogFile}_$counter.txt"
    $counter++
}
New-Item $logFile -ItemType File -Force | Out-Null
"Script Version: $scriptVersion" | Out-File -FilePath $logFile -Encoding UTF8
Write-Log "Script Version: $scriptVersion"

# Optional repair source for DISM /restorehealth - Can be set to a local WIM file if online repair is not possible.
$repairSource = $null  # Example: "WIM:D:\sources\install.wim:1"

# Function to prompt user for Yes/No input - Handles user confirmation with default option.
function Confirm-Action {
    param (
        [string]$Message,
        [string]$Default = "Y"
    )
    $validChoices = @("Y", "N")
    $choice = Read-Host "$Message (Y/N, default: $Default)"
    $choice = $choice.Trim().ToUpper()
    if (-not $choice) {
        $choice = $Default
    }
    if ($choice -notin $validChoices) {
        Write-Host "Invalid input. Using default: $Default" -ForegroundColor Yellow
        return $Default -eq "Y"
    }
    return $choice -eq "Y"
}

# Function to check internet connectivity - Tests connection to Microsoft for DISM online repair.
function Test-InternetConnection {
    try {
        Test-Connection -ComputerName "www.microsoft.com" -Count 1 -Quiet -ErrorAction Stop
        return $true
    } catch {
        return $false
    }
}

# OS Compatibility Check - Ensures the script runs only on supported OS versions.
$osInfo = Get-ComputerInfo
$isServer = $osInfo.OsName -match "Server"
$isWin10OrLater = [System.Version]$osInfo.OsVersion -ge [System.Version]"10.0"
if (-not $isWin10OrLater) {
    Write-Log "Unsupported OS: $($osInfo.OsName). Script optimized for Windows 10/11 and Server 2019+."
    Write-Host "Unsupported OS. Exiting." -ForegroundColor Red
    exit
}
Write-Log "OS Detected: $($osInfo.OsName) - Server: $isServer"

# Initialize summary variables - Tracks errors, repairs, and other metrics across sections for final summary.
$osErrors = 0
$osRepairs = 0
$diskErrors = 0
$diskRepairs = 0
$corruptedShadows = 0
$shadowsDeleted = 0
$defragErrors = 0
$defragOptimizations = 0
$cleanupErrors = 0
$totalBytesFreed = 0
$smartIssues = 0
$driverIssues = 0
$failedUpdateCount = 0
$defenderErrors = 0
$threatCount = 0

# Initial System State Check (Pending Updates and Restarts) - Checks for pending updates and restarts to ensure clean state.
Write-Log "Starting Initial System State Check..."
$pendingUpdates = 0
$pendingUpdateDetails = @()
$pendingRestartSources = @()

# Check for pending Windows Updates - Uses PSWindowsUpdate module or falls back to Get-HotFix.
Write-Log "Checking for pending Windows Updates..."
try {
    if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) {
        Write-Log "Installing PSWindowsUpdate module..."
        Install-Module -Name PSWindowsUpdate -Force -Scope CurrentUser -ErrorAction Stop
        Write-Log "PSWindowsUpdate module installed."
    }
    Import-Module PSWindowsUpdate -ErrorAction Stop
    $updates = Get-WUList -ErrorAction Stop
    $pendingUpdates = ($updates | Where-Object { $_.Status -eq "Pending" -or $_.IsMandatory }).Count
    $pendingUpdateDetails = $updates | Where-Object { $_.Status -eq "Pending" -or $_.IsMandatory } | Select-Object KB, Title
    if ($pendingUpdates -gt 0) {
        Write-Log "Found $pendingUpdates pending updates:"
        $pendingUpdateDetails | ForEach-Object { Write-Log "  KB: $($_.KB), Title: $($_.Title)" }
        Write-Host "`nPending Updates: $pendingUpdates found" -ForegroundColor Yellow
        $pendingUpdateDetails | ForEach-Object { Write-Host "  KB: $($_.KB), Title: $($_.Title)" }
    } else {
        Write-Log "No pending updates found."
        Write-Host "`nPending Updates: None found" -ForegroundColor Green
    }
} catch {
    Write-Log "PSWindowsUpdate unavailable: $_"
    Write-Host "`nPending Updates: PSWindowsUpdate unavailable, falling back to Get-HotFix" -ForegroundColor Yellow
    $recentUpdates = Get-HotFix | Where-Object { $_.InstalledOn -gt (Get-Date).AddDays(-30) }
    $pendingUpdates = $recentUpdates.Count
    $pendingUpdateDetails = $recentUpdates | Select-Object HotFixID, Description
    if ($pendingUpdates -gt 0) {
        Write-Log "Found $pendingUpdates recent updates (past 30 days):"
        $pendingUpdateDetails | ForEach-Object { Write-Log "  HotFixID: $($_.HotFixID), Description: $($_.Description)" }
        Write-Host "Pending Updates: $pendingUpdates recent updates found" -ForegroundColor Yellow
        $pendingUpdateDetails | ForEach-Object { Write-Host "  HotFixID: $($_.HotFixID), Description: $($_.Description)" }
    } else {
        Write-Log "No recent updates found via Get-HotFix."
        Write-Host "Pending Updates: None found via Get-HotFix" -ForegroundColor Green
    }
}

# Check for pending restarts - Inspects registry keys and SCCM for reboot requirements.
Write-Log "Checking for pending restarts..."
if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired") {
    $pendingRestartSources += "Windows Update"
    Write-Log "Pending restart: Windows Update"
    Write-Host "`nPending Restart: Windows Update" -ForegroundColor Yellow
}
if (Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending") {
    $pendingRestartSources += "Component-Based Servicing"
    Write-Log "Pending restart: Component-Based Servicing"
    Write-Host "Pending Restart: Component-Based Servicing" -ForegroundColor Yellow
}
if (Test-Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\PendingFileRenameOperations") {
    $pendingRestartSources += "Pending File Rename Operations"
    Write-Log "Pending restart: Pending File Rename Operations"
    Write-Host "Pending Restart: Pending File Rename Operations" -ForegroundColor Yellow
}
try {
    $sccmReboot = Invoke-CimMethod -Namespace "root\ccm\ClientSDK" -Class "CCM_ClientUtilities" -Name "DetermineIfRebootPending" -ErrorAction Stop
    if ($sccmReboot.RebootPending) {
        $pendingRestartSources += "SCCM Client"
        Write-Log "Pending restart: SCCM Client"
        Write-Host "Pending Restart: SCCM Client" -ForegroundColor Yellow
    }
} catch {
    Write-Log "SCCM client check unavailable: $_"
}

# Prompt for restart if needed - Offers to restart if pending changes are detected.
if ($pendingUpdates -gt 0 -or $pendingRestartSources) {
    Write-Log "Pending updates ($pendingUpdates) or restarts ($($pendingRestartSources -join ', ')) detected."
    Write-Host "`nInitial System State Summary:" -ForegroundColor Green
    Write-Host "Pending Updates: $pendingUpdates"
    Write-Host "Pending Restarts: $($pendingRestartSources -join ', ')"
    if (Confirm-Action -Message "Pending updates or restarts detected. Restart now to apply changes?" -Default "Y") {
        Write-Log "Initiating system restart..."
        Write-Host "Initiating system restart..." -ForegroundColor Cyan
        Restart-Computer -Force
        exit
    } else {
        Write-Log "User declined restart. Proceeding with maintenance."
        Write-Host "`nWarning: Proceeding without restart. Results may be affected." -ForegroundColor Yellow
    }
} else {
    Write-Log "No pending updates or restarts detected."
    Write-Host "`nInitial System State Summary:" -ForegroundColor Green
    Write-Host "Pending Updates: None"
    Write-Host "Pending Restarts: None"
}

# Check for Sysinternals Suite - Downloads and installs if not present for tools like Contig.
$sysinternalsPath = "C:\SysinternalsSuite"
if (-not (Test-Path $sysinternalsPath)) {
    Write-Host "`nSysinternals Suite not found at $sysinternalsPath" -ForegroundColor Yellow
    if (Confirm-Action -Message "Download and extract Sysinternals Suite to $sysinternalsPath?" -Default "N") {
        Write-Log "Starting Sysinternals Suite download..."
        try {
            $zipUrl = "https://download.sysinternals.com/files/SysinternalsSuite.zip"
            $tempZip = [System.IO.Path]::GetTempFileName() + ".zip"
            Invoke-WebRequest -Uri $zipUrl -OutFile $tempZip
            Write-Log "Extracting to $sysinternalsPath..."
            New-Item -Path $sysinternalsPath -ItemType Directory -Force | Out-Null
            Expand-Archive -Path $tempZip -DestinationPath $sysinternalsPath -Force
            Remove-Item -Path $tempZip
            Write-Log "Adding $sysinternalsPath to PATH..."
            $currentPath = [Environment]::GetEnvironmentVariable("Path", "Machine"
            if ($currentPath -notlike "*$sysinternalsPath*") {
                [Environment]::SetEnvironmentVariable("Path", "$currentPath;$sysinternalsPath", "Machine")
            }
            Write-Log "Sysinternals Suite installed."
            Write-Host "`nResult: Sysinternals Suite installed" -ForegroundColor Green
        } catch {
            Write-Log "Error downloading Sysinternals Suite: $_"
            Write-Host "`nResult: Error - $_" -ForegroundColor Red
        }
    } else {
        Write-Log "Skipped Sysinternals Suite download."
        Write-Host "`nResult: Skipped Sysinternals Suite download" -ForegroundColor Green
    }
}

# Check if Contig is available - Used for MFT defragmentation in disk maintenance.
$contigAvailable = Get-Command "contig" -ErrorAction SilentlyContinue

# Step 1: Check TRIM status - Enables TRIM for SSD optimization if not already set.
if (Confirm-Action -Message "Check and enable TRIM for SSD optimization?" -Default "Y") {
    Write-Log "Starting TRIM check..."
    $trimStatus = fsutil behavior query DisableDeleteNotify
    if ($trimStatus -match "DisableDeleteNotify = 0") {
        Write-Log "Result: TRIM is enabled."
        Write-Host "`nTRIM Check Result: Enabled" -ForegroundColor Green
    } else {
        Write-Log "Command: fsutil behavior set DisableDeleteNotify 0"
        fsutil behavior set DisableDeleteNotify 0
        Write-Log "Result: TRIM enabled."
        Write-Host "`nTRIM Check Result: Disabled, now enabled" -ForegroundColor Green
    }
} else {
    Write-Log "Skipped TRIM check."
    Write-Host "`nTRIM Check Result: Skipped" -ForegroundColor Green
}

# Step 2: Get all NTFS drives and their types - Detects drives, media types for optimized handling.
$physicalDisks = Get-PhysicalDisk | Select-Object DeviceId, MediaType, FriendlyName, UniqueId
$ntfsDrives = Get-Volume | Where-Object { $_.FileSystem -eq "NTFS" -and $_.DriveLetter } | ForEach-Object {
    $volume = $_
    $partition = Get-Partition | Where-Object { $_.DriveLetter -eq $volume.DriveLetter }
    $disk = if ($partition) { Get-Disk -Number ($partition.DiskNumber) } else { $null }
    $mediaType = if ($disk) {
        $physicalDisk = $physicalDisks | Where-Object { $_.UniqueId -eq $disk.UniqueId }
        if ($physicalDisk.MediaType) {
            $physicalDisk.MediaType
        } elseif ($physicalDisk.FriendlyName -match "SSD|NVMe") {
            "SSD"
        } else {
            "HDD"
        }
    } else {
        "HDD"
    }
    [PSCustomObject]@{
        DriveLetter = $volume.DriveLetter
        MediaType = $mediaType
        FriendlyName = if ($physicalDisk) { $physicalDisk.FriendlyName } else { "Unknown" }
    }
}
if (-not $ntfsDrives) {
    Write-Log "No NTFS drives found. Exiting."
    Write-Host "`nDrive Detection Summary: No NTFS drives found. Exiting." -ForegroundColor Green
    exit
}
$ssdDrives = $ntfsDrives | Where-Object { $_.MediaType -eq "SSD" } | Select-Object -ExpandProperty DriveLetter
$nonSsdDrives = $ntfsDrives | Where-Object { $_.MediaType -ne "SSD" } | Select-Object -ExpandProperty DriveLetter
Write-Log "Found NTFS drives: $($ntfsDrives.DriveLetter -join ', ')"
Write-Log "SSD drives: $($ssdDrives -join ', ')"
Write-Log "Non-SSD drives: $($nonSsdDrives -join ', ')"
foreach ($drive in $ntfsDrives) {
    Write-Log "Drive $($drive.DriveLetter): MediaType=$($drive.MediaType), FriendlyName=$($drive.FriendlyName)"
}
Write-Host "`nDrive Detection Summary:" -ForegroundColor Green
Write-Host "NTFS Drives: $($ntfsDrives.DriveLetter -join ', ')"
Write-Host "SSD Drives: $($ssdDrives -join ', ')"
Write-Host "Non-SSD Drives: $($nonSsdDrives -join ', ')"

# OS Maintenance Section - Performs DISM and SFC scans/repairs with progress and skips.
if (Confirm-Action -Message "Proceed with OS Maintenance (DISM and SFC)?" -Default "Y") {
    $osCommands = @(
        @{Command = "/online /cleanup-image /checkhealth"; Description = "CheckHealth - Check for component store corruption (dism /online /cleanup-image /checkhealth)"; Executable = "dism"},
        @{Command = "/online /cleanup-image /scanhealth"; Description = "ScanHealth - Perform a deeper scan for corruption (dism /online /cleanup-image /scanhealth)"; Executable = "dism"},
        @{Command = if ($repairSource) { "/online /cleanup-image /restorehealth /source:$repairSource" } else { "/online /cleanup-image /restorehealth" }; Description = "RestoreHealth - Repair the component store (dism /online /cleanup-image /restorehealth$(if ($repairSource) { " /source:$repairSource" }))"; Executable = "dism"},
        @{Command = "/online /cleanup-image /AnalyzeComponentStore"; Description = "AnalyzeComponentStore - Analyze component store size (dism /online /cleanup-image /AnalyzeComponentStore)"; Executable = "dism"},
        @{Command = "/online /cleanup-image /StartComponentCleanup"; Description = "StartComponentCleanup - Clean up superseded components (dism /online /cleanup-image /StartComponentCleanup)"; Executable = "dism"},
        @{Command = "/scannow"; Description = "SFC Scan - Scan and repair system files (sfc /scannow)"; Executable = "sfc"}
    )

    # Pre-check for internet connectivity if no repair source - Ensures online repair is possible or prompts for local source.
    if (-not $repairSource) {
        Write-Log "Checking internet connectivity for DISM /restorehealth..."
        if (-not (Test-InternetConnection)) {
            Write-Log "No internet connection. DISM /restorehealth may fail."
            Write-Host "`nWarning: No internet connection. DISM /restorehealth may fail." -ForegroundColor Yellow
            if (Confirm-Action -Message "Specify a local repair source (e.g., WIM:D:\sources\install.wim:1)? (default: N)" -Default "N") {
                $repairSource = Read-Host "Enter repair source (e.g., WIM:D:\sources\install.wim:1)"
                Write-Log "Repair source specified: $repairSource"
                $osCommands[2].Command = "/online /cleanup-image /restorehealth /source:$repairSource"
                $osCommands[2].Description = "RestoreHealth - Repair the component store (dism /online /cleanup-image /restorehealth /source:$repairSource)"
            } else {
                Write-Log "No repair source provided. Using online DISM /restorehealth."
                Write-Host "Proceeding with online DISM /restorehealth." -ForegroundColor Yellow
            }
        } else {
            Write-Log "Internet connection detected."
            Write-Host "`nInternet connection detected for DISM /restorehealth." -ForegroundColor Green
        }
    }

    # Check if SFC has been run - Prompts to run SFC first if no recent scan detected.
    $sfcRun = (Get-WinEvent -FilterHashtable @{LogName='System'; ID=1001; ProviderName='Microsoft-Windows-WindowsUpdateClient'} -MaxEvents 10 -ErrorAction SilentlyContinue | Where-Object { $_.Message -match "sfc /scannow" }).Count
    if ($sfcRun -eq 0) {
        Write-Log "No recent SFC scan detected. Recommending SFC before DISM /restorehealth."
        Write-Host "`nNo recent SFC scan detected." -ForegroundColor Yellow
        if (Confirm-Action -Message "Run SFC /scannow before DISM /restorehealth?" -Default "Y") {
            $sfcCommand = $osCommands | Where-Object { $_.Executable -eq "sfc" }
            Write-Log "Starting: $($sfcCommand.Description)"
            Write-Host "`nRunning: $($sfcCommand.Description)" -ForegroundColor Cyan
            Write-Log "Command: $($sfcCommand.Executable) $($sfcCommand.Command)"
            try {
                $tempOutFile = [System.IO.Path]::GetTempFileName()
                $tempErrFile = [System.IO.Path]::GetTempFileName()
                $process = Start-Process -FilePath $sfcCommand.Executable -ArgumentList $sfcCommand.Command -NoNewWindow -RedirectStandardOutput $tempOutFile -RedirectStandardError $tempErrFile -PassThru -Wait
                $output = Get-Content $tempOutFile -ErrorAction SilentlyContinue
                $errorOutput = Get-Content $tempErrFile -ErrorAction SilentlyContinue
                Remove-Item $tempOutFile
                Remove-Item $tempErrFile
                $combinedOutput = $output
                if ($errorOutput) {
                    $combinedOutput += $errorOutput
                }
                $combinedOutput | Out-File -FilePath $logFile -Append -Encoding UTF8
                $combinedOutput | Write-Host
                if ($combinedOutput -match "found.*and repaired") {
                    Write-Log "Result: Repairs completed."
                    Write-Host "`nResult: Repairs completed" -ForegroundColor Green
                    $osRepairs++
                } elseif ($combinedOutput -match "corrupt|cannot repair") {
                    Write-Log "Result: Corruption detected."
                    Write-Host "`nResult: Corruption detected" -ForegroundColor Yellow
                    $osErrors++
                } else {
                    Write-Log "Result: No corruption detected."
                    Write-Host "`nResult: No corruption detected" -ForegroundColor Green
                }
            } catch {
                Write-Log "Result: Error - $_"
                Write-Host "`nResult: Error - $_" -ForegroundColor Red
                $osErrors++
            }
        } else {
            Write-Log "Skipped SFC /scannow before DISM /restorehealth."
            Write-Host "`nResult: Skipped SFC /scannow" -ForegroundColor Green
        }
    }

    $skipScanHealth = $false
    $skipRestoreHealth = $false
    $skipComponentCleanup = $false

    foreach ($cmd in $osCommands) {
        if ($cmd.Description -match "SFC Scan" -and $sfcRun -gt 0) {
            Write-Log "Skipping: $($cmd.Description) (already run)"
            Write-Host "`nSkipping: $($cmd.Description)" -ForegroundColor Green
            continue
        }
        if ($cmd.Description -match "ScanHealth" -and $skipScanHealth) {
            Write-Log "Skipping: $($cmd.Description) (no corruption in CheckHealth)"
            Write-Host "`nSkipping: $($cmd.Description)" -ForegroundColor Green
            continue
        }
        if ($cmd.Description -match "RestoreHealth" -and $skipRestoreHealth) {
            Write-Log "Skipping: $($cmd.Description) (no corruption in CheckHealth)"
            Write-Host "`nSkipping: $($cmd.Description)" -ForegroundColor Green
            continue
        }
        if ($cmd.Description -match "StartComponentCleanup" -and $skipComponentCleanup) {
            Write-Log "Skipping: $($cmd.Description) (cleanup not recommended)"
            Write-Host "`nSkipping: $($cmd.Description)" -ForegroundColor Green
            continue
        }

        Write-Log "Starting: $($cmd.Description)"
        Write-Host "`nRunning: $($cmd.Description)" -ForegroundColor Cyan
        if (Confirm-Action -Message "Proceed with $($cmd.Description)?" -Default "Y") {
            Write-Log "Command: $($cmd.Executable) $($cmd.Command)"
            try {
                $tempOutFile = [System.IO.Path]::GetTempFileName()
                $tempErrFile = [System.IO.Path]::GetTempFileName()
                $process = Start-Process -FilePath $cmd.Executable -ArgumentList ($cmd.Command -split " ") -NoNewWindow -RedirectStandardOutput $tempOutFile -RedirectStandardError $tempErrFile -PassThru
                $startTime = Get-Date
                $timeout = 3600 # 1 hour
                $stallTimeout = 600 # 10 minutes
                $lastPercentage = 0
                $lastChangeTime = $startTime
                while (-not $process.HasExited) {
                    Start-Sleep -Milliseconds 500
                    $elapsed = (Get-Date) - $startTime
                    if ($elapsed.TotalSeconds -gt $timeout) {
                        Write-Log "Result: Terminated due to timeout ($timeout seconds)."
                        Write-Host "`nResult: Terminated due to timeout" -ForegroundColor Red
                        Stop-Process -Id $process.Id -Force
                        $osErrors++
                        break
                    }
                    $output = Get-Content $tempOutFile -Raw -ErrorAction SilentlyContinue
                    if ($output) {
                        $lines = $output -split "`n"
                        foreach ($line in $lines) {
                            if ($line -match "\[\=+\s*(\d+\.\d+)%\s*\]") {
                                $percentage = [double]$matches[1]
                                if ($percentage -gt $lastPercentage) {
                                    $lastPercentage = $percentage
                                    $lastChangeTime = Get-Date
                                    Write-Progress -Activity $cmd.Description -PercentComplete $percentage -Status "Progress: $percentage%"
                                }
                            }
                        }
                        $elapsedSinceChange = (Get-Date) - $lastChangeTime
                        if ($lastPercentage -gt 0 -and $elapsedSinceChange.TotalSeconds -gt $stallTimeout) {
                            Write-Log "Result: Terminated due to stall at $lastPercentage% for $stallTimeout seconds."
                            Write-Host "`nResult: Terminated due to stall" -ForegroundColor Red
                            Stop-Process -Id $process.Id -Force
                            $osErrors++
                            break
                        }
                    }
                }
                if (-not $process.HasExited) {
                    continue
                }
                $process.WaitForExit()
                $output = Get-Content $tempOutFile -ErrorAction SilentlyContinue
                $errorOutput = Get-Content $tempErrFile -ErrorAction SilentlyContinue
                Remove-Item $tempOutFile
                Remove-Item $tempErrFile

                # Filter output for logging - Removes redundant progress lines to clean up logs.
                $progressPattern = "\[\=+\s*\d+\.\d+%\s*\]"
                $finalPercentage = $null
                $filteredOutput = @()
                foreach ($line in ($output + $errorOutput)) {
                    if ($line -match $progressPattern) {
                        $finalPercentage = $line
                    } elseif ($line -and $line -notmatch $progressPattern) {
                        $filteredOutput += $line
                    }
                }
                if ($finalPercentage) {
                    $filteredOutput += $finalPercentage
                }
                $filteredOutput | Out-File -FilePath $logFile -Append -Encoding UTF8
                $filteredOutput | Write-Host

                # Determine and display result - Parses output to categorize success/error for summary.
                $resultMessage = "Unknown"
                $resultColor = "Yellow"
                if ($cmd.Description -match "CheckHealth") {
                    if ($filteredOutput -match "No component store corruption detected") {
                        $resultMessage = "Success: No corruption detected"
                        $resultColor = "Green"
                        if (Confirm-Action -Message "No corruption found. Skip ScanHealth and RestoreHealth?" -Default "N") {
                            $skipScanHealth = $true
                            $skipRestoreHealth = $true
                        }
                    } else {
                        $resultMessage = "Error: Corruption detected"
                        $resultColor = "Yellow"
                        $osErrors++
                    }
                } elseif ($cmd.Description -match "ScanHealth") {
                    if ($filteredOutput -match "corrupt|error|failed|component store corruption") {
                        $resultMessage = "Error: Corruption detected"
                        $resultColor = "Yellow"
                        $osErrors++
                    } else {
                        $resultMessage = "Success: No corruption detected"
                        $resultColor = "Green"
                        if (Confirm-Action -Message "No corruption found. Skip RestoreHealth?" -Default "N") {
                            $skipRestoreHealth = $true
                        }
                    }
                } elseif ($cmd.Description -match "RestoreHealth") {
                    if ($filteredOutput -match "successfully repaired|restored") {
                        $resultMessage = "Success: Repairs completed"
                        $resultColor = "Green"
                        $osRepairs++
                    } elseif ($filteredOutput -match "corrupt|error|failed|component store corruption") {
                        $resultMessage = "Error: Errors encountered"
                        $resultColor = "Yellow"
                        $osErrors++
                    } else {
                        $resultMessage = "Success: Operation completed"
                        $resultColor = "Green"
                    }
                } elseif ($cmd.Description -match "AnalyzeComponentStore") {
                    if ($filteredOutput -match "reclaimable.*: *0" -or $filteredOutput -notmatch "reclaim.*recommended") {
                        $resultMessage = "Success: Cleanup not recommended"
                        $resultColor = "Green"
                        if (Confirm-Action -Message "Cleanup not recommended. Skip StartComponentCleanup?" -Default "N") {
                            $skipComponentCleanup = $true
                        }
                    } else {
                        $resultMessage = "Success: Cleanup recommended"
                        $resultColor = "Yellow"
                    }
                } elseif ($cmd.Description -match "StartComponentCleanup") {
                    if ($filteredOutput -match "successfully completed") {
                        $resultMessage = "Success: Cleanup completed"
                        $resultColor = "Green"
                        $osRepairs++
                    } elseif ($filteredOutput -match "error|failed") {
                        $resultMessage = "Error: Errors encountered"
                        $resultColor = "Yellow"
                        $osErrors++
                    } else {
                        $resultMessage = "Success: Operation completed"
                        $resultColor = "Green"
                    }
                } elseif ($cmd.Description -match "SFC Scan") {
                    if ($filteredOutput -match "found.*and repaired") {
                        $resultMessage = "Success: Repairs completed"
                        $resultColor = "Green"
                        $osRepairs++
                    } elseif ($filteredOutput -match "corrupt|cannot repair") {
                        $resultMessage = "Error: Corruption detected"
                        $resultColor = "Yellow"
                        $osErrors++
                    } else {
                        $resultMessage = "Success: No corruption detected"
                        $resultColor = "Green"
                    }
                }
                Write-Log "Result: $resultMessage"
                Write-Host "`nResult: $resultMessage" -ForegroundColor $resultColor
                Write-Progress -Activity $cmd.Description -Completed
            } catch {
                Write-Log "Result: Error - $_"
                Write-Host "`nResult: Error - $_" -ForegroundColor Red
                $osErrors++
            }
        } else {
            Write-Log "Result: Skipped $($cmd.Description)"
            Write-Host "`nResult: Skipped" -ForegroundColor Green
        }
    }

    Write-Log "OS Maintenance Summary: Errors=$osErrors, Repairs=$osRepairs"
    Write-Host "`nOS Maintenance Summary:" -ForegroundColor Green
    Write-Host "Errors Detected: $osErrors"
    Write-Host "Repairs Made: $osRepairs"
    if ($skipScanHealth -and $skipRestoreHealth) {
        Write-Log "Skipped ScanHealth and RestoreHealth: No corruption in CheckHealth"
        Write-Host "Skipped ScanHealth and RestoreHealth: No corruption in CheckHealth"
    } elseif ($skipRestoreHealth) {
        Write-Log "Skipped RestoreHealth: No corruption in ScanHealth"
        Write-Host "Skipped RestoreHealth: No corruption in ScanHealth"
    }
    if ($skipComponentCleanup) {
        Write-Log "Skipped StartComponentCleanup: Not recommended"
        Write-Host "Skipped StartComponentCleanup: Not recommended"
    }
    if ($osErrors -gt 0) {
        Write-Log "Recommendation: Review DISM.log and CBS.log for details."
        Write-Host "Recommendation: Review DISM.log and CBS.log for details" -ForegroundColor Yellow
    }
} else {
    Write-Log "OS Maintenance Summary: Skipped"
    Write-Host "`nOS Maintenance Summary: Skipped" -ForegroundColor Green
}

# Disk Maintenance Section - Handles disk checks, repairs, and Contig for each NTFS drive.
if (Confirm-Action -Message "Proceed with Disk Maintenance (CHKDSK, fsutil, Contig)?" -Default "Y") {
    $contigOutputs = @{}
    $dirtyVolumes = @()
    $lowSpaceDrives = @()

    foreach ($drive in $ntfsDrives.DriveLetter) {
        $drivePath = "$drive`:"
        Write-Log "Starting Disk Maintenance for $drivePath..."

        $dirtyStatus = fsutil dirty query $drivePath
        if ($dirtyStatus -match "IS dirty") {
            Write-Log "Command: chkdsk $drivePath /f"
            chkdsk $drivePath /f
            $dirtyVolumes += $drivePath
            $diskRepairs++
            Write-Log "Result: $drivePath marked dirty, CHKDSK /f scheduled."
            Write-Host "`n$drivePath Result: Marked dirty, CHKDSK /f scheduled" -ForegroundColor Yellow
        } else {
            Write-Log "Result: $drivePath not dirty."
            Write-Host "`n$drivePath Result: Not dirty" -ForegroundColor Green
        }

        $volumeInfo = Get-Volume -DriveLetter $drive
        if ($volumeInfo.SizeRemaining / $volumeInfo.Size -lt 0.1) {
            Write-Log "Result: Low free space on $drivePath (<10%)."
            $lowSpaceDrives += $drivePath
            Write-Host "$drivePath Result: Low free space (<10%)" -ForegroundColor Yellow
        } else {
            Write-Log "Result: Sufficient free space on $drivePath."
            Write-Host "$drivePath Result: Sufficient free space" -ForegroundColor Green
        }

        Write-Log "Command: fsutil repair state $drivePath"
        $repairState = fsutil repair state $drivePath
        $repairState | Out-File -FilePath $logFile -Append -Encoding UTF8
        if ($repairState -match "0x00") {
            Write-Log "Result: $drivePath is clean (0x00)."
            Write-Host "$drivePath Result: Clean (0x00)" -ForegroundColor Green
        } else {
            Write-Log "Command: fsutil repair initiate $drivePath"
            fsutil repair initiate $drivePath
            Write-Log "Command: chkdsk $drivePath /f /sdcleanup"
            chkdsk $drivePath /f /sdcleanup
            Write-Log "Result: Corruption detected ($repairState), CHKDSK /f /sdcleanup scheduled."
            Write-Host "$drivePath Result: Corruption detected ($repairState), CHKDSK /f /sdcleanup scheduled" -ForegroundColor Yellow
            $diskRepairs++
            $diskErrors++
        }

        $chkdskScanCmd = "chkdsk /scan $drivePath"
        Write-Log "Starting: CHKDSK Scan on $drivePath ($chkdskScanCmd)"
        Write-Host "`nRunning: CHKDSK Scan on $drivePath ($chkdskScanCmd)" -ForegroundColor Cyan
        if (Confirm-Action -Message "Proceed with CHKDSK Scan on $drivePath ($chkdskScanCmd)?" -Default "Y") {
            Write-Log "Command: $chkdskScanCmd"
            $output = Invoke-Expression "$chkdskScanCmd 2>&1"
            $output | Out-File -FilePath $logFile -Append -Encoding UTF8
            Write-Host $output
            if ($output -match "found.*bad|corruption|error") {
                Write-Log "Result: Errors found on $drivePath."
                Write-Host "`nResult: Errors found on $drivePath" -ForegroundColor Yellow
                $diskErrors++
            } else {
                Write-Log "Result: No errors found on $drivePath."
                Write-Host "`nResult: No errors found on $drivePath" -ForegroundColor Green
            }
        } else {
            Write-Log "Result: Skipped CHKDSK Scan on $drivePath."
            Write-Host "`nResult: Skipped for $drivePath" -ForegroundColor Green
        }

        if ($contigAvailable) {
            $contigCmd = "contig -v -accepteula $drivePath\`$MFT"
            Write-Log "Starting: Contig on MFT for $drivePath ($contigCmd)"
            Write-Host "`nRunning: Contig on MFT for $drivePath ($contigCmd)" -ForegroundColor Cyan
            if (Confirm-Action -Message "Proceed with Contig on MFT for $drivePath ($contigCmd)?" -Default "Y") {
                Write-Log "Command: $contigCmd"
                $output = Invoke-Expression "$contigCmd 2>&1"
                $contigOutputs[$drivePath] = $output
                $output | Out-File -FilePath $logFile -Append -Encoding UTF8
                Write-Host $output
                $fragmentMatch = $output | Select-String "is in (\d+) fragments"
                $fragments = if ($fragmentMatch) { [int]$fragmentMatch.Matches.Groups[1].Value } else { 0 }
                if ($output -match "error|failed|cannot open") {
                    Write-Log "Result: Errors encountered on $drivePath."
                    Write-Host "`nResult: Errors encountered on $drivePath" -ForegroundColor Yellow
                    $diskErrors++
                } else {
                    Write-Log "Result: MFT on $drivePath in $fragments fragments."
                    Write-Host "`nResult: MFT on $drivePath in $fragments fragments" -ForegroundColor Green
                }
            } else {
                Write-Log "Result: Skipped Contig on $drivePath."
                Write-Host "`nResult: Skipped for $drivePath" -ForegroundColor Green
            }
        } else {
            Write-Log "Result: Skipped Contig on $drivePath (Contig not available)."
            Write-Host "`nResult: Skipped for $drivePath (Contig not available)" -ForegroundColor Yellow
        }
    }

    Write-Log "Disk Maintenance Summary: Dirty Volumes=$($dirtyVolumes -join ', '), Low Space Drives=$($lowSpaceDrives -join ', '), Errors=$diskErrors, Repairs=$diskRepairs"
    Write-Host "`nDisk Maintenance Summary:" -ForegroundColor Green
    Write-Host "Dirty Volumes: $($dirtyVolumes -join ', ')"
    Write-Host "Low Space Drives: $($lowSpaceDrives -join ', ')"
    Write-Host "Errors Detected: $diskErrors"
    Write-Host "Repairs/Scheduled Fixes: $diskRepairs"
    if ($dirtyVolumes.Count -gt 0) {
        Write-Log "Recommendation: Reboot to complete CHKDSK fixes on: $($dirtyVolumes -join ', ')"
        Write-Host "Recommendation: Reboot to complete CHKDSK fixes on: $($dirtyVolumes -join ', ')" -ForegroundColor Yellow
    }
    if ($diskErrors -gt 0) {
        Write-Log "Recommendation: Run full CHKDSK /f /r on affected drives."
        Write-Host "Recommendation: Run full CHKDSK /f /r on affected drives" -ForegroundColor Yellow
    }
} else {
    Write-Log "Disk Maintenance Summary: Skipped"
    Write-Host "`nDisk Maintenance Summary: Skipped" -ForegroundColor Green
}

# Shadow Copy Maintenance Section - Checks and repairs shadow copies, creates restore point if corruption found.
if (Confirm-Action -Message "Proceed with Shadow Copy Maintenance?" -Default "Y") {
    $shadowStates = @{}
    $restorePointCreated = $false

    foreach ($drive in $ntfsDrives.DriveLetter) {
        $drivePath = "$drive`:"
        Write-Log "Starting Shadow Copy Maintenance for $drivePath..."

        Write-Log "Command: vssadmin list shadows /for=$drivePath"
        $shadowList = vssadmin list shadows /for=$drivePath
        $shadowList | Out-File -FilePath $logFile -Append -Encoding UTF8
        $shadowCopies = $shadowList | Select-String "Shadow Copy ID: {(.+?)}" | ForEach-Object { $_.Matches.Groups[1].Value }
        $shadowVolumes = $shadowList | Select-String "Shadow Copy Volume: (.+?)$" | ForEach-Object { $_.Matches.Groups[1].Value }

        if ($shadowCopies) {
            Write-Log "Found $($shadowCopies.Count) shadow copies for $drivePath."
            Write-Host "`n$drivePath Shadow Copies: Found $($shadowCopies.Count)" -ForegroundColor Green
            $driveShadowStates = @()
            for ($i = 0; $i -lt $shadowCopies.Count; $i++) {
                $shadowId = $shadowCopies[$i]
                $shadowVolume = $shadowVolumes[$i]
                Write-Log "Command: fsutil repair state $shadowVolume"
                $shadowRepairState = fsutil repair state $shadowVolume
                $shadowRepairState | Out-File -FilePath $logFile -Append -Encoding UTF8
                $driveShadowStates += $shadowRepairState
                if ($shadowRepairState -match "0x00") {
                    Write-Log "Result: Shadow copy $shadowVolume is clean (0x00)."
                    Write-Host "Shadow Copy ${shadowVolume}: Clean (0x00)" -ForegroundColor Green
                } else {
                    Write-Log "Command: vssadmin delete shadows /shadow=$shadowId /quiet"
                    vssadmin delete shadows /shadow=$shadowId /quiet
                    Write-Log "Result: Deleted corrupted shadow copy $shadowId."
                    Write-Host "Shadow Copy ${shadowVolume}: Corrupted ($shadowRepairState), deleted" -ForegroundColor Yellow
                    $corruptedShadows++
                    $shadowsDeleted++
                }
            }
            $shadowStates[$drivePath] = $driveShadowStates
        } else {
            Write-Log "Result: No shadow copies found for $drivePath."
            Write-Host "`n$drivePath Shadow Copies: None found" -ForegroundColor Green
        }
    }

    if ($ntfsDrives.DriveLetter -contains "C" -and ($shadowStates.Values | ForEach-Object { $_ | Select-String "0x00" -NotMatch })) {
        Write-Log "Command: Checkpoint-Computer -Description 'Post-ShadowCopyCleanup Restore Point $((Get-Date -Format 'yyyy-MM-dd HH:mm:ss'))' -RestorePointType MODIFY_SETTINGS"
        try {
            Checkpoint-Computer -Description "Post-ShadowCopyCleanup Restore Point $((Get-Date -Format 'yyyy-MM-dd HH:mm:ss'))" -RestorePointType MODIFY_SETTINGS
            Write-Log "Result: Restore point created for C:."
            Write-Host "`nC: Restore Point: Created" -ForegroundColor Green
            $restorePointCreated = $true
        } catch {
            Write-Log "Result: Error creating restore point for C: - $_"
            Write-Host "`nC: Restore Point: Error - $_" -ForegroundColor Red
        }
    }

    Write-Log "Shadow Copy Maintenance Summary: Corrupted Shadows=$corruptedShadows, Shadows Deleted=$shadowsDeleted, Restore Point Created=$($restorePointCreated)"
    Write-Host "`nShadow Copy Maintenance Summary:" -ForegroundColor Green
    Write-Host "Corrupted Shadow Copies: $corruptedShadows"
    Write-Host "Shadow Copies Deleted: $shadowsDeleted"
    Write-Host "New Restore Point for C: $(if ($restorePointCreated) { 'Created' } else { 'Not created' })"
} else {
    Write-Log "Shadow Copy Maintenance Summary: Skipped"
    Write-Host "`nShadow Copy Maintenance Summary: Skipped" -ForegroundColor Green
}

# Optimization Section - Optimizes drives based on media type (TRIM for SSD, defrag for HDD).
if (Confirm-Action -Message "Proceed with Drive Optimization (defrag /C /O /V)?" -Default "Y") {
    Write-Log "Starting Drive Optimization..."
    if ($ssdDrives) {
        $defragCmd = "defrag /C /O /V"
        Write-Log "Starting: SSD Optimization ($defragCmd)"
        Write-Host "`nRunning: SSD Optimization ($defragCmd)" -ForegroundColor Cyan
        Write-Log "Command: $defragCmd"
        $defragOutput = defrag /C /O /V 2>&1
        $defragOutput | Out-File -FilePath $logFile -Append -Encoding UTF8
        Write-Host $defragOutput
        if ($defragOutput -match "optimized|trimmed") {
            Write-Log "Result: TRIM completed for $($ssdDrives -join ', ')."
            Write-Host "`nResult: TRIM completed for $($ssdDrives -join ', ')" -ForegroundColor Green
            $defragOptimizations++
        } elseif ($defragOutput -match "error|failed") {
            Write-Log "Result: Errors encountered."
            Write-Host "`nResult: Errors encountered" -ForegroundColor Yellow
            $defragErrors++
        }
    }
    if ($nonSsdDrives) {
        $defragCmd = "defrag /C /O /V"
        Write-Log "Starting: Non-SSD Optimization ($defragCmd)"
        Write-Host "`nNon-SSD drives detected: $($nonSsdDrives -join ', ')" -ForegroundColor Yellow
        if (Confirm-Action -Message "Proceed with defrag for non-SSD drives ($defragCmd)? (may be time-consuming)" -Default "N") {
            Write-Log "Command: $defragCmd"
            $defragOutput = defrag /C /O /V 2>&1
            $defragOutput | Out-File -FilePath $logFile -Append -Encoding UTF8
            Write-Host $defragOutput
            if ($defragOutput -match "defragmented") {
                Write-Log "Result: Defragmentation completed for $($nonSsdDrives -join ', ')."
                Write-Host "`nResult: Defragmentation completed for $($nonSsdDrives -join ', ')" -ForegroundColor Green
                $defragOptimizations++
            } elseif ($defragOutput -match "error|failed") {
                Write-Log "Result: Errors encountered."
                Write-Host "`nResult: Errors encountered" -ForegroundColor Yellow
                $defragErrors++
            }
        } else {
            Write-Log "Result: Skipped non-SSD defragmentation."
            Write-Host "`nResult: Skipped for $($nonSsdDrives -join ', ')" -ForegroundColor Green
        }
    }
    if (-not $ssdDrives -and -not $nonSsdDrives) {
        Write-Log "Result: No eligible drives for optimization."
        Write-Host "`nResult: No eligible drives" -ForegroundColor Green
    }

    Write-Log "Drive Optimization Summary: Errors=$defragErrors, Optimizations=$defragOptimizations"
    Write-Host "`nDrive Optimization Summary:" -ForegroundColor Green
    Write-Host "Errors Detected: $defragErrors"
    Write-Host "Optimizations Performed: $defragOptimizations"
} else {
    Write-Log "Drive Optimization Summary: Skipped"
    Write-Host "`nDrive Optimization Summary: Skipped" -ForegroundColor Green
}

# Temp File Cleanup Section - Cleans temporary files and update cache to free space.
if (Confirm-Action -Message "Proceed with Temp File Cleanup?" -Default "Y") {
    Write-Log "Starting Temp File Cleanup..."

    function Get-FolderSize {
        param($Path)
        try {
            if (Test-Path $Path) {
                $size = (Get-ChildItem $Path -Recurse -File -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum -ErrorAction SilentlyContinue).Sum
                return [math]::Round($size / 1MB, 2)
            }
            return 0
        } catch {
            Write-Log "Result: Error calculating size for ${Path}: $_"
            Write-Host "`nResult for ${Path}: Error - $_" -ForegroundColor Red
            return 0
        }
    }

    $sysTempPath = "C:\Windows\Temp"
    Write-Log "Starting: System Temp Cleanup ($sysTempPath)"
    $beforeSize = Get-FolderSize -Path $sysTempPath
    try {
        Get-ChildItem $sysTempPath -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        $afterSize = Get-FolderSize -Path $sysTempPath
        $freed = $beforeSize - $afterSize
        $totalBytesFreed += $freed
        Write-Log "Result: Freed $freed MB from $sysTempPath."
        Write-Host "`nSystem Temp Cleanup Result: Freed $freed MB from $sysTempPath" -ForegroundColor Green
    } catch {
        Write-Log "Result: Error cleaning ${sysTempPath}: $_"
        Write-Host "`nSystem Temp Cleanup Result: Error - $_" -ForegroundColor Red
        $cleanupErrors++
    }

    $userTempPath = $env:TEMP
    Write-Log "Starting: User Temp Cleanup ($userTempPath)"
    $beforeSize = Get-FolderSize -Path $userTempPath
    try {
        Get-ChildItem $userTempPath -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        $afterSize = Get-FolderSize -Path $userTempPath
        $freed = $beforeSize - $afterSize
        $totalBytesFreed += $freed
        Write-Log "Result: Freed $freed MB from $userTempPath."
        Write-Host "`nUser Temp Cleanup Result: Freed $freed MB from $userTempPath" -ForegroundColor Green
    } catch {
        Write-Log "Result: Error cleaning ${userTempPath}: $_"
        Write-Host "`nUser Temp Cleanup Result: Error - $_" -ForegroundColor Red
        $cleanupErrors++
    }

    $updatePath = "C:\Windows\SoftwareDistribution\Download"
    Write-Log "Starting: Windows Update Cache Cleanup ($updatePath)"
    try {
        Stop-Service -Name wuauserv -Force -ErrorAction SilentlyContinue
        $beforeSize = Get-FolderSize -Path $updatePath
        Get-ChildItem $updatePath -Recurse -Force -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
        $afterSize = Get-FolderSize -Path $updatePath
        $freed = $beforeSize - $afterSize
        $totalBytesFreed += $freed
        Write-Log "Result: Freed $freed MB from $updatePath."
        Write-Host "`nWindows Update Cache Cleanup Result: Freed $freed MB from $updatePath" -ForegroundColor Green
        Start-Service -Name wuauserv -ErrorAction SilentlyContinue
    } catch {
        Write-Log "Result: Error cleaning ${updatePath}: $_"
        Write-Host "`nWindows Update Cache Cleanup Result: Error - $_" -ForegroundColor Red
        $cleanupErrors++
        Start-Service -Name wuauserv -ErrorAction SilentlyContinue
    }

    Write-Log "Temp File Cleanup Summary: Freed=$totalBytesFreed MB, Errors=$cleanupErrors"
    Write-Host "`nTemp File Cleanup Summary:" -ForegroundColor Green
    Write-Host "Total Space Freed: $totalBytesFreed MB"
    Write-Host "Errors Encountered: $cleanupErrors"
} else {
    Write-Log "Temp File Cleanup Summary: Skipped"
    Write-Host "`nTemp File Cleanup Summary: Skipped" -ForegroundColor Green
}

# Hardware and Driver Checks Section - Checks disk health, SMART attributes, and driver issues.
if (Confirm-Action -Message "Proceed with Hardware and Driver Checks?" -Default "Y") {
    Write-Log "Starting Hardware and Driver Checks..."
    $physicalDisks = Get-PhysicalDisk
    $reliability = $physicalDisks | Get-StorageReliabilityCounter
    foreach ($disk in $physicalDisks) {
        if ($disk.HealthStatus -ne "Healthy") {
            Write-Log "Result: Unhealthy disk: $($disk.DeviceId) - Status: $($disk.HealthStatus)"
            Write-Host "`nDisk $($disk.DeviceId) Result: Unhealthy - $($disk.HealthStatus)" -ForegroundColor Yellow
            $smartIssues++
        } else {
            Write-Log "Result: Disk $($disk.DeviceId) is healthy."
            Write-Host "`nDisk $($disk.DeviceId) Result: Healthy" -ForegroundColor Green
        }
    }
    foreach ($counter in $reliability) {
        if ($counter.ReadErrorsTotal -gt 0 -or $counter.WriteErrorsTotal -gt 0 -or $counter.Wear -gt 90) {
            Write-Log "Result: SMART issues on disk: ReadErrors=$($counter.ReadErrorsTotal), WriteErrors=$($counter.WriteErrorsTotal), Wear=$($counter.Wear)%"
            Write-Host "Disk SMART Result: ReadErrors=$($counter.ReadErrorsTotal), WriteErrors=$($counter.WriteErrorsTotal), Wear=$($counter.Wear)%" -ForegroundColor Yellow
            $smartIssues++
        }
    }

    Write-Log "Command: Get-CimInstance Win32_PnPSignedDriver"
    $problemDrivers = Get-CimInstance Win32_PnPSignedDriver | Where-Object { $_.Status -ne "OK" -or -not $_.IsSigned }
    $driverIssues = if ($problemDrivers) { $problemDrivers.Count } else { 0 }
    if ($problemDrivers) {
        Write-Log "Command: pnputil /scan-devices"
        pnputil /scan-devices
        Write-Log "Result: $driverIssues problem drivers found."
        Write-Host "`nDriver Check Result: $driverIssues problem drivers found" -ForegroundColor Yellow
    } else {
        Write-Log "Result: No problem drivers found."
        Write-Host "`nDriver Check Result: No problem drivers found" -ForegroundColor Green
    }

    Write-Log "Hardware and Driver Checks Summary: SMART Issues=$smartIssues, Problem Drivers=$driverIssues"
    Write-Host "`nHardware and Driver Checks Summary:" -ForegroundColor Green
    Write-Host "SMART Issues: $smartIssues"
    Write-Host "Problem Drivers: $driverIssues"
    if ($smartIssues -gt 0) {
        Write-Log "Recommendation: Run full hardware diagnostics (e.g., CrystalDiskInfo)."
        Write-Host "Recommendation: Run full hardware diagnostics (e.g., CrystalDiskInfo)" -ForegroundColor Yellow
    }
    if ($driverIssues -gt 0) {
        Write-Log "Recommendation: Update or rollback drivers via Device Manager."
        Write-Host "Recommendation: Update or rollback drivers via Device Manager" -ForegroundColor Yellow
    }
} else {
    Write-Log "Hardware and Driver Checks Summary: Skipped"
    Write-Host "`nHardware and Driver Checks Summary: Skipped" -ForegroundColor Green
}

# Memory and Update Checks Section - Checks for failed updates and schedules memory diagnostic if not server.
if (Confirm-Action -Message "Proceed with Memory and Update Checks?" -Default "Y") {
    Write-Log "Starting Memory and Update Checks..."
    Write-Log "Command: Get-HotFix"
    $failedUpdates = Get-HotFix | Where-Object { $_.Status -ne "Succeeded" }
    $failedUpdateCount = if ($failedUpdates) { $failedUpdates.Count } else { 0 }
    if ($failedUpdates) {
        Write-Log "Command: wuauclt /detectnow"
        wuauclt /detectnow
        Write-Log "Result: $failedUpdateCount failed updates found."
        Write-Host "`nUpdate Check Result: $failedUpdateCount failed updates found" -ForegroundColor Yellow
    } else {
        Write-Log "Result: No failed updates found."
        Write-Host "`nUpdate Check Result: No failed updates found" -ForegroundColor Green
    }

    $memoryDiagnosticScheduled = $false
    if (-not $isServer -and (Confirm-Action -Message "Schedule Windows Memory Diagnostic on next reboot?" -Default "N")) {
        Write-Log "Command: mdsched.exe /scheduleboot"
        mdsched.exe /scheduleboot
        Write-Log "Result: Memory Diagnostic scheduled."
        Write-Host "`nMemory Diagnostic Result: Scheduled" -ForegroundColor Green
        $memoryDiagnosticScheduled = $true
    } else {
        Write-Log "Result: Memory Diagnostic not scheduled (skipped on servers)."
        Write-Host "`nMemory Diagnostic Result: Not scheduled" -ForegroundColor Green
    }

    Write-Log "Memory and Update Checks Summary: Failed Updates=$failedUpdateCount, Memory Diagnostic=$($memoryDiagnosticScheduled)"
    Write-Host "`nMemory and Update Checks Summary:" -ForegroundColor Green
    Write-Host "Failed Updates: $failedUpdateCount"
    Write-Host "Memory Diagnostic: $(if ($memoryDiagnosticScheduled) { 'Scheduled' } else { 'Not scheduled' })"
} else {
    Write-Log "Memory and Update Checks Summary: Skipped"
    Write-Host "`nMemory and Update Checks Summary: Skipped" -ForegroundColor Green
}

# Malware Scan Section - Performs quick Defender scan, handles third-party AV.
if (Confirm-Action -Message "Proceed with Quick Malware Scan (Windows Defender)?" -Default "Y") {
    Write-Log "Starting Quick Malware Scan..."
    $defenderService = Get-Service -Name WinDefend -ErrorAction SilentlyContinue
    $thirdPartyAV = Get-CimInstance -Namespace "root/SecurityCenter2" -ClassName AntiVirusProduct -ErrorAction SilentlyContinue
    $defenderEnabled = $true
    $defenderRecommendations = @()

    if ($thirdPartyAV) {
        Write-Log "Result: Third-party antivirus detected: $($thirdPartyAV.displayName -join ', ')"
        Write-Host "`nThird-party antivirus detected: $($thirdPartyAV.displayName -join ', ')" -ForegroundColor Yellow
        $defenderEnabled = $false
        $defenderRecommendations += "Verify third-party antivirus status."
    }

    if ($defenderService) {
        if ($defenderService.Status -ne "Running") {
            Write-Log "Command: Start-Service -Name WinDefend"
            try {
                Start-Service -Name WinDefend -ErrorAction Stop
                Write-Log "Result: Windows Defender service started."
                Write-Host "`nDefender Service Result: Started" -ForegroundColor Green
            } catch {
                Write-Log "Result: Failed to start Windows Defender: $_"
                Write-Host "`nDefender Service Result: Error - $_" -ForegroundColor Red
                $defenderEnabled = $false
                $defenderRecommendations += "Check Windows Defender in services.msc."
            }
        } else {
            Write-Log "Result: Windows Defender service is running."
            Write-Host "`nDefender Service Result: Running" -ForegroundColor Green
        }
    } else {
        Write-Log "Result: Windows Defender service not found."
        Write-Host "`nDefender Service Result: Not found" -ForegroundColor Red
        $defenderEnabled = $false
        $defenderRecommendations += "Reinstall Windows Defender."
    }

    if ($defenderEnabled) {
        Write-Log "Starting: Quick Malware Scan (Start-MpScan -ScanType QuickScan)"
        Write-Host "`nRunning: Quick Malware Scan (Start-MpScan -ScanType QuickScan)" -ForegroundColor Cyan
        Write-Log "Command: Start-MpScan -ScanType QuickScan"
        try {
            Start-MpScan -ScanType QuickScan -ErrorAction Stop
            $defenderEvents = Get-WinEvent -FilterHashtable @{
                LogName = 'Microsoft-Windows-Windows Defender/Operational'
                ID = @(1000, 1001)
                StartTime = (Get-Date).AddHours(-1)
            } -ErrorAction SilentlyContinue
            $threats = $defenderEvents | Where-Object { $_.Message -match "threat detected" }
            $threatCount = if ($threats) { $threats.Count } else { 0 }
            if ($threats) {
                Write-Log "Result: $threatCount threats detected."
                Write-Host "`nResult: $threatCount threats detected" -ForegroundColor Yellow
                $defenderRecommendations += "Run full scan (Start-MpScan -ScanType FullScan)."
            } else {
                Write-Log "Result: No threats found."
                Write-Host "`nResult: No threats found" -ForegroundColor Green
            }
        } catch {
            Write-Log "Result: Error running scan: $_"
            Write-Host "`nResult: Error - $_" -ForegroundColor Red
            $defenderRecommendations += "Update Defender definitions (MpCmdRun -SignatureUpdate)."
            $defenderErrors++
        }
    } else {
        Write-Log "Result: Skipped scan due to Defender being disabled."
        Write-Host "`nResult: Skipped due to Defender disabled" -ForegroundColor Yellow
        $defenderRecommendations += "Enable Windows Defender via gpedit.msc."
    }

    Write-Log "Malware Scan Summary: Defender Enabled=$($defenderEnabled), Threats Detected=$(if ($defenderEnabled) { $threatCount } else { 'N/A' })"
    Write-Host "`nMalware Scan Summary:" -ForegroundColor Green
    Write-Host "Defender Enabled: $(if ($defenderEnabled) { 'Yes' } else { 'No' })"
    Write-Host "Threats Detected: $(if ($defenderEnabled) { $threatCount } else { 'N/A' })"
    if ($defenderRecommendations) {
        Write-Log "Recommendations: $($defenderRecommendations -join '; ')"
        Write-Host "Recommendations:" -ForegroundColor Yellow
        $defenderRecommendations | ForEach-Object { Write-Host "- $_" }
    }
} else {
    Write-Log "Malware Scan Summary: Skipped"
    Write-Host "`nMalware Scan Summary: Skipped" -ForegroundColor Green
}

# Verify VSS service - Ensures Volume Shadow Copy service is running for shadow copy operations.
Write-Log "Starting VSS Service Check..."
Write-Log "Command: Get-Service -Name VSS"
$vssStatus = Get-Service -Name VSS
if ($vssStatus.Status -eq "Running") {
    Write-Log "Result: VSS service is running."
    Write-Host "`nVSS Service Result: Running" -ForegroundColor Green
} else {
    Write-Log "Command: Start-Service -Name VSS"
    Start-Service -Name VSS
    Write-Log "Result: VSS service started."
    Write-Host "`nVSS Service Result: Started" -ForegroundColor Green
}

# Log and Event Log Analysis Section - Analyzes logs and events for errors and repairs.
if (Confirm-Action -Message "Proceed with Log Analysis?" -Default "Y") {
    Write-Log "Starting Log Analysis..."
    $dismLogPath = "$env:windir\Logs\DISM\dism.log"
    $cbsLogPath = "$env:windir\Logs\CBS\cbs.log"
    
    $dismErrors = 0
    $dismRepairs = 0
    $cbsErrors = 0
    $cbsRepairs = 0
    $chkdskErrors = 0
    $chkdskRepairs = 0
    $contigErrorsPerDrive = @{}
    $contigFragmentsPerDrive = @{}
    $fsutilCorruptedDrives = 0
    $vssErrors = 0
    $hardwareErrors = 0
    $driverErrors = 0

    $errorPattern = "error|failed|failure|corrupt|component store corruption|CBS operation failed"
    $repairPattern = "repaired|restored|fixed|successfully repaired"
    $chkdskErrorPattern = "found \d+ bad|corruption|error"
    $chkdskRepairPattern = "repaired|fixed|corrected|cleaned"
    $contigErrorPattern = "error|failed|cannot open"
    $contigFragmentPattern = "is in (\d+) fragments"
    $fsutilCorruptionPattern = "0x[1-9A-F]"
    $shadowCorruptionPattern = "0x[1-9A-F]"
    $defragErrorPattern = "error|failed"
    $defragOptPattern = "optimized|trimmed|defragmented"
    $cleanupErrorPattern = "Error cleaning.*Temp|SoftwareDistribution"
    $defenderErrorPattern = "Error running Quick Malware Scan"
    $serverErrorPattern = "WSUS|Server-specific error"  # Added for server

    if (Test-Path $dismLogPath) {
        $dismErrors = (Select-String -Path $dismLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $dismRepairs = (Select-String -Path $dismLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
        Write-Log "DISM.log Analysis: Errors=$dismErrors, Repairs=$dismRepairs"
        Write-Host "`nDISM.log Analysis: Errors=$dismErrors, Repairs=$dismRepairs" -ForegroundColor Green
    } else {
        Write-Log "DISM.log not found at $dismLogPath"
        Write-Host "`nDISM.log not found at $dismLogPath" -ForegroundColor Yellow
    }
    
    if (Test-Path $cbsLogPath) {
        $cbsErrors = (Select-String -Path $cbsLogPath -Pattern $errorPattern -CaseSensitive:$false | Measure-Object).Count
        $cbsRepairs = (Select-String -Path $cbsLogPath -Pattern $repairPattern -CaseSensitive:$false | Measure-Object).Count
        Write-Log "CBS.log Analysis: Errors=$cbsErrors, Repairs=$cbsRepairs"
        Write-Host "CBS.log Analysis: Errors=$cbsErrors, Repairs=$cbsRepairs" -ForegroundColor Green
    } else {
        Write-Log "CBS.log not found at $cbsLogPath"
        Write-Host "CBS.log not found at $cbsLogPath" -ForegroundColor Yellow
    }
    
    $eventIds = @(7,11,50,55,98,137,140,153,219,41,7023,2004,1001,12289,12290)
    $systemEvents = Get-WinEvent -FilterHashtable @{LogName='System'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $appEvents = Get-WinEvent -FilterHashtable @{LogName='Application'; ID=$eventIds; StartTime=(Get-Date).AddHours(-48)} -ErrorAction SilentlyContinue
    $allEvents = $systemEvents + $appEvents

    $diskErrors = $allEvents | Where-Object { $_.Id -in @(7,11,50,55,98,137,140,153) } | Measure-Object | Select-Object -ExpandProperty Count
    $driverErrors = $allEvents | Where-Object { $_.Id -in @(219,7023) } | Measure-Object | Select-Object -ExpandProperty Count
    $hardwareErrors = $allEvents | Where-Object { $_.Id -in @(41,2004,1001) } | Measure-Object | Select-Object -ExpandProperty Count
    $vssErrors = $allEvents | Where-Object { $_.Id -in @(12289,12290) } | Measure-Object | Select-Object -ExpandProperty Count
    
    foreach ($drivePath in $contigOutputs.Keys) {
        $driveType = ($ntfsDrives | Where-Object { $_.DriveLetter -eq $drivePath[0] }).MediaType
        $output = $contigOutputs[$drivePath]
        $contigErrorsPerDrive[$drivePath] = ($output | Select-String -Pattern $contigErrorPattern -CaseSensitive:$false | Measure-Object).Count
        $fragmentMatch = $output | Select-String -Pattern $contigFragmentPattern -CaseSensitive:$false
        $contigFragmentsPerDrive[$drivePath] = if ($fragmentMatch) { [int]$fragmentMatch.Matches.Groups[1].Value } else { 0 }
        Write-Log "Contig Analysis for $drivePath ($driveType): Errors=$($contigErrorsPerDrive[$drivePath]), Fragments=$($contigFragmentsPerDrive[$drivePath])"
        Write-Host "Contig Analysis for $drivePath ($driveType): Errors=$($contigErrorsPerDrive[$drivePath]), Fragments=$($contigFragmentsPerDrive[$drivePath])" -ForegroundColor Green
    }
    
    $fsutilCorruptedDrives = (Select-String -Path $logFile -Pattern $fsutilCorruptionPattern | Measure-Object).Count
    $shadowCorrupted = (Select-String -Path $logFile -Pattern $shadowCorruptionPattern | Measure-Object).Count
    $defragErrors = (Select-String -Path $logFile -Pattern $defragErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $defragOptimizations = (Select-String -Path $logFile -Pattern $defragOptPattern -CaseSensitive:$false | Measure-Object).Count
    $cleanupErrors = (Select-String -Path $logFile -Pattern $cleanupErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $defenderErrors = (Select-String -Path $logFile -Pattern $defenderErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $chkdskErrors = (Select-String -Path $logFile -Pattern $chkdskErrorPattern -CaseSensitive:$false | Measure-Object).Count
    $chkdskRepairs = (Select-String -Path $logFile -Pattern $chkdskRepairPattern -CaseSensitive:$false | Measure-Object).Count
    $serverErrors = if ($isServer) { (Select-String -Path $logFile -Pattern $serverErrorPattern -CaseSensitive:$false | Measure-Object).Count } else { 0 }

    Write-Log "CHKDSK Analysis: Errors=$chkdskErrors, Repairs=$chkdskRepairs"
    Write-Host "CHKDSK Analysis: Errors=$chkdskErrors, Repairs=$chkdskRepairs" -ForegroundColor Green
    Write-Log "fsutil Analysis: Corrupted Drives=$fsutilCorruptedDrives"
    Write-Host "fsutil Analysis: Corrupted Drives=$fsutilCorruptedDrives" -ForegroundColor Green
    Write-Log "Shadow Copy Analysis: Corrupted Shadows=$shadowCorrupted"
    Write-Host "Shadow Copy Analysis: Corrupted Shadows=$shadowCorrupted" -ForegroundColor Green
    Write-Log "Defrag Analysis: Errors=$defragErrors, Optimizations=$defragOptimizations"
    Write-Host "Defrag Analysis: Errors=$defragErrors, Optimizations=$defragOptimizations" -ForegroundColor Green
    Write-Log "Cleanup Analysis: Errors=$cleanupErrors"
    Write-Host "Cleanup Analysis: Errors=$cleanupErrors" -ForegroundColor Green
    Write-Log "Defender Analysis: Errors=$defenderErrors"
    Write-Host "Defender Analysis: Errors=$defenderErrors" -ForegroundColor Green
    Write-Log "Event Log Analysis: Disk Errors=$diskErrors, Driver Errors=$driverErrors, Hardware Errors=$hardwareErrors, VSS Errors=$vssErrors"
    Write-Host "Event Log Analysis: Disk Errors=$diskErrors, Driver Errors=$driverErrors, Hardware Errors=$hardwareErrors, VSS Errors=$vssErrors" -ForegroundColor Green
    if ($isServer) {
        Write-Log "Server-Specific Analysis: Errors=$serverErrors"
        Write-Host "Server-Specific Analysis: Errors=$serverErrors" -ForegroundColor Green
    }

    $recommendations = @()
    if ($dismErrors + $cbsErrors + $chkdskErrors + $diskErrors + $defragErrors + $cleanupErrors + $defenderErrors + $serverErrors -gt 0) {
        $recommendations += "Review detailed logs for errors."
        if ($isServer) { $recommendations += "Check WSUS configuration for server updates." }
    }
    if ($recommendations) {
        Write-Log "Recommendations: $($recommendations -join '; ')"
        Write-Host "Recommendations:" -ForegroundColor Yellow
        $recommendations | ForEach-Object { Write-Host "- $_" }
    }

    Write-Log "Log Analysis Summary: Total Errors Detected=$($dismErrors + $cbsErrors + $chkdskErrors + $diskErrors + $defragErrors + $cleanupErrors + $defenderErrors + $serverErrors)"
    Write-Host "`nLog Analysis Summary: Total Errors Detected=$($dismErrors + $cbsErrors + $chkdskErrors + $diskErrors + $defragErrors + $cleanupErrors + $defenderErrors + $serverErrors)" -ForegroundColor Green
} else {
    Write-Log "Log Analysis Summary: Skipped"
    Write-Host "`nLog Analysis Summary: Skipped" -ForegroundColor Green
}

# Final Summary Section - Aggregates all metrics and provides overall recommendations.
Write-Log "Starting Final Summary..."
Write-Host "`nFinal Summary:" -ForegroundColor Cyan
Write-Log "Script Version: $scriptVersion"
Write-Host "Script Version: $scriptVersion"
Write-Log "OS Errors: $osErrors, Repairs: $osRepairs"
Write-Host "OS Errors: $osErrors, Repairs: $osRepairs"
Write-Log "Disk Errors: $diskErrors, Repairs: $diskRepairs"
Write-Host "Disk Errors: $diskErrors, Repairs: $diskRepairs"
Write-Log "Corrupted Shadows: $corruptedShadows, Deleted: $shadowsDeleted"
Write-Host "Corrupted Shadows: $corruptedShadows, Deleted: $shadowsDeleted"
Write-Log "Defrag Errors: $defragErrors, Optimizations: $defragOptimizations"
Write-Host "Defrag Errors: $defragErrors, Optimizations: $defragOptimizations"
Write-Log "Cleanup Errors: $cleanupErrors, Bytes Freed: $totalBytesFreed MB"
Write-Host "Cleanup Errors: $cleanupErrors, Bytes Freed: $totalBytesFreed MB"
Write-Log "SMART Issues: $smartIssues, Driver Issues: $driverIssues"
Write-Host "SMART Issues: $smartIssues, Driver Issues: $driverIssues"
Write-Log "Failed Updates: $failedUpdateCount"
Write-Host "Failed Updates: $failedUpdateCount"
Write-Log "Defender Errors: $defenderErrors, Threats: $threatCount"
Write-Host "Defender Errors: $defenderErrors, Threats: $threatCount"

$totalErrors = $osErrors + $diskErrors + $defragErrors + $cleanupErrors + $smartIssues + $driverIssues + $defenderErrors + $failedUpdateCount + $corruptedShadows
$totalRepairs = $osRepairs + $diskRepairs + $defragOptimizations + $shadowsDeleted
Write-Log "Overall: Total Errors=$totalErrors, Total Repairs/Optimizations=$totalRepairs"
Write-Host "Overall: Total Errors=$totalErrors, Total Repairs/Optimizations=$totalRepairs"

$finalRecommendations = @()
if ($totalErrors -gt 0) {
    $finalRecommendations += "Address remaining errors; consider full system scan or reboot."
}
if ($isServer) {
    $finalRecommendations += "Verify server-specific configurations (e.g., WSUS, roles)."
}
if ($finalRecommendations) {
    Write-Log "Final Recommendations: $($finalRecommendations -join '; ')"
    Write-Host "Final Recommendations:" -ForegroundColor Yellow
    $finalRecommendations | ForEach-Object { Write-Host "- $_" }
}

Write-Log "Script execution completed."
Write-Host "`nScript execution completed." -ForegroundColor Cyan